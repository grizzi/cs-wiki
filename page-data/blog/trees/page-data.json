{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/trees/","result":{"data":{"markdownRemark":{"html":"<p>Trees are a convenient way to represent an expressions or hierarchies. A binary search tree is a particular tree with the following properties:</p>\n<ul>\n<li>Each node has 2 children</li>\n<li>The left node is less than or equal to its parent, the right node is greater than its parent. </li>\n<li>We can define a tree recursively. Each child is itself a binary search tree.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 246px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQ4y3WT14oCQRBF+/8/xidFMCEiZhFzDmNAxSxiGB13z1pL79jj9kPTVVPh1q076uufY9t2t9tttVqbzQbz+Xx6Y5TXJXHL5bLZbOZyOcuy7vf7xwbKyNEP2haLxXK5zH29XrXfDeEtmSCarFYreq7X69PptN1uuTudjvS/XC6O47wlS7HD4VCv12u1ms/nA7P45dPj8QgGg8lkkoB+v/8heTKZzOfzUqm0WCzcIOVB/2g0yhSRSORD8m63y2azwpCXXsgnM5VKAU1//Usej8dMyFS9Xk8GM/IBz9jD4RAUv52d10mn0xQWF/hDoZD9Ot4VUj0QCOz3e2qp6XQKB+FwGNgaIeMhj9FoZDQXRIlEolKpAFANBgOQzGYzNiQR5/OZTLhlYfTxKg/OoSYejyvSeFHJDRJW+IbT6CxmPp+nOSV+ZoYG9+oxkRdx3Mfj0dAW08o4pCgDEsfv9yMpTOhAMNQSUNz8JHj0LMqNh2jmzGQyQh4rKRQKmIx2u92YDiEA+G3Pui2rbjQa5CM12RnleONH6rFYDIa5zR9DKhEBSVDNDkUVvKvVKuLBbLfbaEHLnvsbnSC72LVB1XcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        title=\"811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        src=\"/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        srcset=\"/static/c9b69f168752b5455f22568d5c7b7272/04472/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png 170w,\n/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png 246w\"\n        sizes=\"(max-width: 246px) 100vw, 246px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Definitions</h3>\n<table>\n<thead>\n<tr>\n<th><strong>Name</strong></th>\n<th><strong>Meaning</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Ancestor</strong></td>\n<td>any other node which is above in the tree: parent, parent of parent, and so on...</td>\n</tr>\n<tr>\n<td><strong>Siblings</strong></td>\n<td>two nodes sharing the same parents</td>\n</tr>\n<tr>\n<td><strong>Leaf</strong></td>\n<td>node without children</td>\n</tr>\n<tr>\n<td><strong>Level</strong></td>\n<td>1 + number of edges between the root and the node (e.g 8 is at level 1 in the previous tree)</td>\n</tr>\n<tr>\n<td><strong>Interior Node</strong></td>\n<td>node that is not a leaf</td>\n</tr>\n<tr>\n<td><strong>Height</strong></td>\n<td>maximum depth of subtree node and farthest leaf. In previous tree, that would be 4, e.g from 8 → 3 → 6 → 7</td>\n</tr>\n<tr>\n<td><strong>Forest</strong></td>\n<td>collection of trees</td>\n</tr>\n<tr>\n<td><strong>Node</strong></td>\n<td>contains a key and a listen of children. Optionally, a node can have a parent (as in doubly linked lists)</td>\n</tr>\n</tbody>\n</table>\n<h3>Trees common procedures</h3>\n<p>Since trees are recursively defined, it is common to have routines that are recursive</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// assumes a binary tree</span>\nsize_t <span class=\"token function\">height</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">height</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">height</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nsize_t <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> </code></pre></div>\n<h3>Walking a tree</h3>\n<p>Often we want to visit the nodes of a tree in a particular order. For example, print the nodes of a tree</p>\n<ul>\n<li>depth first search (DFS): we completely traverse one sub-tree before exploring a sibling sub-treee</li>\n<li>breadth first search (BFS): we traverse all nodes at one level before progressing to the next level. </li>\n</ul>\n<h3>Depth First Search</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">depth_first</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t  <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n  <span class=\"token function\">depth_first</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">do_something_with_key</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">depth_first</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>if the function <code class=\"language-text\">do_something_with_key</code> prints the key, then the output for the previous binary tree would be:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 246px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQ4y3WT14oCQRBF+/8/xidFMCEiZhFzDmNAxSxiGB13z1pL79jj9kPTVVPh1q076uufY9t2t9tttVqbzQbz+Xx6Y5TXJXHL5bLZbOZyOcuy7vf7xwbKyNEP2haLxXK5zH29XrXfDeEtmSCarFYreq7X69PptN1uuTudjvS/XC6O47wlS7HD4VCv12u1ms/nA7P45dPj8QgGg8lkkoB+v/8heTKZzOfzUqm0WCzcIOVB/2g0yhSRSORD8m63y2azwpCXXsgnM5VKAU1//Usej8dMyFS9Xk8GM/IBz9jD4RAUv52d10mn0xQWF/hDoZD9Ot4VUj0QCOz3e2qp6XQKB+FwGNgaIeMhj9FoZDQXRIlEolKpAFANBgOQzGYzNiQR5/OZTLhlYfTxKg/OoSYejyvSeFHJDRJW+IbT6CxmPp+nOSV+ZoYG9+oxkRdx3Mfj0dAW08o4pCgDEsfv9yMpTOhAMNQSUNz8JHj0LMqNh2jmzGQyQh4rKRQKmIx2u92YDiEA+G3Pui2rbjQa5CM12RnleONH6rFYDIa5zR9DKhEBSVDNDkUVvKvVKuLBbLfbaEHLnvsbnSC72LVB1XcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        title=\"811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        src=\"/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png\"\n        srcset=\"/static/c9b69f168752b5455f22568d5c7b7272/04472/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png 170w,\n/static/c9b69f168752b5455f22568d5c7b7272/92252/811c82f70bca1c8aa2b989136c5d0e245e381ff2.png 246w\"\n        sizes=\"(max-width: 246px) 100vw, 246px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>1 → 3 → 4 → 6 → 7 → 10 → 13 → 14 </p>\n<p>In-order traversal: the nodes where printed in sorted order! This is because we always print children that are left nodes, then the node and the children on the right node and this is respecting the fact that <code class=\"language-text\">left nodes</code>  <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\leq\"></img> <code class=\"language-text\">central node</code>  <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?<\"></img> <code class=\"language-text\">right node</code>.</p>\n<p>Pre-order traversal: we can put the <code class=\"language-text\">do_something_with_key</code>  routine before the calls to <code class=\"language-text\">depth_first</code> and this would print the nodes as they are encountered instead.</p>\n<p>Post-order traversal: we can put the <code class=\"language-text\">do_something_with_key</code> routine after the calls to <code class=\"language-text\">depth_first</code> and this would print the nodes from leaves to parents.</p>\n<p>These functions are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. We prove this by substitution. At each operation we split the tree in two subtrees with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n-k-1 \"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> nodes. Then if the <code class=\"language-text\">do_something_with_key</code> operation takes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)= c\"></img> the recursion is: </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\begin{cases}\nT(0) &amp;= c \\\\ \nT(n) &amp;= T(k) + T(n-k-1) + c\n\\end{cases}\"></div>\n<p>We prove the time complexity using the substitution method. We assume that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?T(n) = (c+d)n + c\"></img>. The base case is verified: <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?T(0) = (c+d)0 + c = c\"></img>. We are left to prove the recursive case which is, assuming that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d > c\"></img>: </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\begin{align}\nT(n) &amp;\\leq T(k) + T(n-k-1) + d \\\\\n&amp;= (c+d)k + c + (c+d)(n-k) -c -d + c + d \\\\\n&amp;= (c+d)n + c\n\\end{align}\"></div>\n<p>Computing the same result with the graphic method. In the worst case, we have only one children. That means we have n levels and for each we need one calculation. The result is again <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. What if the tree is perfectly balanced. Then we have <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2 n\"></img> levels. For each we perform 1, 2, 4, 8 computations and so forth. That means the total computation is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Sigma_{j=0}^{\\log_2n} 2^j = 2*2^{\\log_2n} -1 = 2n - 1 \\leq 2n = O(n)\"></img></p>\n<hr>\n<h3>Space Complexity</h3>\n<p>We refer to space complexity as the amount of memory required by an algorithm. For example for breadth first, is the amount of space we need to allocate in the queue, or the number of recursive calls.</p>\n<hr>\n<p>In the worst case of completely unbalanced tree, we need to put n functions on the call stack. Then the space complexity is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. In the best case of perfectly balanced tree (one children left and one right) instead, we have at maximum the amount of calls as the levels which are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2n\"></img>.</p>\n<h3>Breadth First Search</h3>\n<p>With breadth first we go level by level. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// always assuming binary trees</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">breadth_first</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>  \n  <span class=\"token punctuation\">}</span>\n  Queue q<span class=\"token punctuation\">;</span>\n  q<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    node <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">do_something_with_node</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// put all the children node of the current node on the top of the queue, </span>\n    <span class=\"token comment\">// so that next, they will be processed first</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      q<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      q<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The output of the previous algorithm for the previous tree would be: 8 →3 → 10 → 1 → 6 → 14 → 4 → 7 → 13. As we go through each node once, the time complexity of breadth first is also <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>.</p>\n<p>In the best case where all parents have only one children space complexity is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>, instead if the tree is perfectly balanced, in the worst case we will enqueue all the nodes of some level which will be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n/2 \"></img> → <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n/2)\"></img></p>\n<h3>Search</h3>\n<p>We exploit the fact that going left or right we have larger or smaller value of the parent node.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// recursion</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&lt;</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Insertion</h3>\n<p>Very similar to search, when we find the value, we do not insert. If we do not we insert left or right, according to the comparison wrt to the parent</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> tree <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> value <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"is already in the tree\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token comment\">// recursion</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&lt;</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Insertion takes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(h)\"></img> time, where <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h\"></img> is the height of the tree. In the worst case this is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> but for a perfectly balanced binary search tree this is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(\\log n)\"></img> . </p>\n<h3>Deletion</h3>\n<p>Deletion is more tricky since deleting a node, means that we have to connect all neighboring nodes that got disconnected such that the remaining tree stays a valid binary tree. If the node to be deleted is a left, its easy: we just get rid of the node. When we delete a node inside the tree? There are three cases here:</p>\n<ul>\n<li>The node is a leaf node: in this case we simply delete the node and update the parent node to have a nullptr.</li>\n<li>If the node has only 1 child : in this case the child inherit the parent from the deleted node. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 677px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c01843fa88f51583f5449663a28e16b4/68de2/2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.05882352941177%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACsklEQVQ4y51Ty27TUBD1H/ALbPgGFnwQX4DYsENiWwRBLapUQC1UXSCVAhKiFRVV00ealqZp3KRpGj+S2G6dxI7txI4fh7m+cYhgx5VGvj6eOXPmYSGJASQJkpgbEGHsRmiUQhwtn8Ja24RavoY1twTtzl30lzfAThJG3J+FzJjAycCdCLCHgGECyrULTbVTP9fz4ATj9M4dwckmhFMxKSGRxVGEkRPCkENcPXyKL/ef4GC1Dn84iabjDRysly7wodJA3xtx3vgPWTIhFpKEazXkBDeSh60Hj/H93iMkUn1SWow45qRrpSpeFUWU6w1EQYAojDEVzQQzQvbS2A+hX45Q3Oqj2ZxxirK+0glDmK0WvxPmj3y4jgvP9TCmdmDiJ4z8AG/3FSzuVWB2B9w/ilOyTJnhDrFwImKzLvHvWRJ6hOMQQ2rH7kUd78RrTvhJaWHppAybsnFCriwLFJU25o9FfC7XeG0T0qx37Jzpt5jLn7Ap80zj4RBO30JMCWYb41MSx7JomyIEbNqWnZaf9S0r1TIM+I5DQyEgijjY1G6QK5SxrRjQLAdvxCY+/hKp/Giq5FztIEeDyatGKiSgktevVLwunNHKjbjCbId6tA4rVRl5rYu62sZCsYK9jpmqyMqvtjXME17o3KYxDH5PSVfFBlyqTmATYhawSdH2I/Dhdbuwuz0q30dCCmJmtCaWacLu9ZDQnZXNlPuDAZ8++URkgk09scjY4l61NLw8LGFx5wA9IrTtAVwKqMgtPN8/xUr+CK7N/Afw6NuppOLZjwN8LYlpvNW3IRi6AV0zYBo3qDVlzO8WsUF/hKHphOspft5oIrdTwLdyNX3XCO/S8/iygRc/D7FdqcFkPGSC1JSQmSrJ0BUFHVnGP7iqov0X3pKZP8OVKSbUqjXMWnVi/4v/BmcmXlhTsMBfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png\"\n        title=\"2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png\"\n        src=\"/static/c01843fa88f51583f5449663a28e16b4/68de2/2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png\"\n        srcset=\"/static/c01843fa88f51583f5449663a28e16b4/04472/2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png 170w,\n/static/c01843fa88f51583f5449663a28e16b4/9f933/2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png 340w,\n/static/c01843fa88f51583f5449663a28e16b4/68de2/2e3e26d9f28b3c6e08dd4a809b2ffcf385adc067.png 677w\"\n        sizes=\"(max-width: 677px) 100vw, 677px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>If the node has two children then we need to find a value that can exchange the one to delete. We look for the smallest value larger then the node to be deleted. In fact this node is a valid parent of the right subtree (smaller then all the values there) but still larger then the value to be deleted, therefore valid parent of the left subtree as well. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/522b8b55eb6281e057d41ee15dc3dd31/c3a47/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABgklEQVQoz0WRS2/aUBCF/f8XVaVuuqlaZd1NqyjqoooqRQKKBfgRQoKB1GBs/MDGF3DBGH+5tqG9m5kzc+bM4yoUBa0wYfz1juz7PdUrTwVlWTZ+bUrO5wa/pltUbcTx3U2Nq3h5yUkPpTv3alBEa6IPHymOOddXESvhq/ijv8bbiNr/kv7EOrj/uReeYkcJ80Sw8CO81m9KKbgWO3yxvzAbcmVFdmAaxtixoBNOyPI9YpvxGqf/hJW/eUF/6dNbeHjHog6Og4ihG3DKT+TF+aLaFIzleZ68gKmX1NhNU8zlisPhyFYOo3TsJTvZGVn8MLEppdueODV5JouNVXTdiYncYlRh2aTvuLjxnl/akizLCVKB6vgooR8wnC9pjyxEtOHz/AcPjs4u3hKGEZu0uVl3ZqO9WPiSf6tqRCJB/3RH6/0tnqwLVysimVOs5xf5awadgc7s2eKbeU/nqYc1GjN8HOIsmmmnf2x6vQGGbqD2NQzTRGt3GbRUdN2UcR1d03kDA7kKiVC9/M0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png\"\n        title=\"892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png\"\n        src=\"/static/522b8b55eb6281e057d41ee15dc3dd31/c5bb3/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png\"\n        srcset=\"/static/522b8b55eb6281e057d41ee15dc3dd31/04472/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 170w,\n/static/522b8b55eb6281e057d41ee15dc3dd31/9f933/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 340w,\n/static/522b8b55eb6281e057d41ee15dc3dd31/c5bb3/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 680w,\n/static/522b8b55eb6281e057d41ee15dc3dd31/b12f7/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 1020w,\n/static/522b8b55eb6281e057d41ee15dc3dd31/b5a09/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 1360w,\n/static/522b8b55eb6281e057d41ee15dc3dd31/c3a47/892f1ca2cdd4dd7e6a8dc5979139b983ce74dfcb.png 1601w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>What if the smallest larger value then the node to be deleted is not a leaf? This can only happen if it has only a right subtree connected (otherwise we could continue our search forward). The full right subtree moves with this node. We do not have to swap all the children, it is then sufficient to swap the two nodes and inherit the parent.  </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/75216b1339c9897c7b3186567b7a17e1/bed7a/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.64705882352941%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABpklEQVQoz0WQWW/TQBSF/cN55aUPvCF+Ay8VEilIRSCoSpumcUz21UmsJLUd17GzOHa8fYwnJlzpaLZvzpy5CqIeLJdee8T+zRVJGBdb5FkuRS6XZNl5Yu4CHlc20dsPMDHlcZ5mkit4xdz4LIXstYt3fUO6fpVQkqbCRUB5LlXUantg6Xr42yNa647Odnx5TAYQnPJtbBS35IFz9Q6n8rWMVII5F8P6as3C3ch5JdT4uL2HuODS/wkPQUhtadF6cWiYawn/2jR5vzsb/0uYlaYd00F9WVMT3y1qLhJXF/alTUqYZHTsDbrtolsOcZgyTWxutyrH4ESSZefApaHu7ZkIbhcEDGwHP4qJ4nPCQsoxjPjS14miU9E4Kt0R3u4kv1zsz1xfGsVJQrDb8ziaYjguWRRxN5iwED2PjyGH/YHgEKD8aHbpjnU855Xe1OC71sa2LEwhy7TZlD2Lw5CfWoubWgNnuaTZH3L9UGM+m0vNpjOMuYHy6b7Kc7ONPhzxW/3DZwGNBkMG/QG9ThfDMKSh7/lUq08811XUUk+1uhwb5VpraPwFgYdUsKWgtKYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png\"\n        title=\"9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png\"\n        src=\"/static/75216b1339c9897c7b3186567b7a17e1/c5bb3/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png\"\n        srcset=\"/static/75216b1339c9897c7b3186567b7a17e1/04472/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 170w,\n/static/75216b1339c9897c7b3186567b7a17e1/9f933/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 340w,\n/static/75216b1339c9897c7b3186567b7a17e1/c5bb3/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 680w,\n/static/75216b1339c9897c7b3186567b7a17e1/b12f7/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 1020w,\n/static/75216b1339c9897c7b3186567b7a17e1/b5a09/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 1360w,\n/static/75216b1339c9897c7b3186567b7a17e1/bed7a/9ad34e32acdb03a58e6522cc2df1cfa7a5817961.png 1437w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/* Finds the minimum node */</span>\nTree<span class=\"token operator\">*</span> <span class=\"token function\">find_min</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n\tTree<span class=\"token operator\">*</span> min_node <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>min_node<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    min_node <span class=\"token operator\">=</span> min_node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> min_node<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">bool</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">*</span> tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> value <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"is not in the tree\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>children <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// handle the case with no childre</span>\n      <span class=\"token keyword\">delete</span> tree<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      tree<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">delete</span> tree<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token comment\">// handle the case with one childre</span>\n\n\t\t<span class=\"token comment\">// we need to promote one child as new parent</span>\n    <span class=\"token comment\">// we look at the minimum node larger then the current node</span>\n    Tree<span class=\"token operator\">*</span> min_max_node <span class=\"token operator\">=</span> <span class=\"token function\">find_min</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   \n    <span class=\"token comment\">// interchange with found value</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min_max_node<span class=\"token punctuation\">.</span><span class=\"token function\">is_leaf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      min_max_node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n      min_max_node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n      min_max_node<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n      min_max_node<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n      min_max_node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> tree<span class=\"token operator\">-></span>left\n      <span class=\"token comment\">// no need to change the right subtree</span>\n    <span class=\"token punctuation\">}</span>\n    tree<span class=\"token operator\">-></span>right<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> min_max_node<span class=\"token punctuation\">;</span>\n    tree<span class=\"token operator\">-></span>left<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> min_max_node<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">delete</span> tree<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token comment\">// recursion</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&lt;</span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> tree<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Sub-trees size</h3>\n<p> We can keep track of the subtree sizes by associating with each node a number defining the size (number of nodes in the subtree). Every time there is a insert or delete, the associated size is increased or diminished.</p>\n<h3>Analysis</h3>\n<ul>\n<li>Runtime: when it is perfectly balance, we do <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2n\"></img> operations but, with perfectly ordered values the time complexity grows to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img></li>\n<li>Usage: </li>\n</ul>\n<h2>Red-Black Trees</h2>\n<p>In a binary search tree all operations are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(h)\"></img> where <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h\"></img> is the height of the tree.  If its height is large, many of this operations will be no faster than operations on a linked list. Red-Black trees are one of many search tree schemes that are balanced in order to guarantee that basic dynamic-set operations (delete, insert, ...) take <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(\\log n)\"></img>. </p>\n<h3>Properties of a Black-Red Tree</h3>\n<ul>\n<li>A red-black tree is a binary search tree with one extra bit of storage per node: its color: this can be either RED or BLACK.</li>\n<li>Each node on the tree contains attributes: <code class=\"language-text\">color</code>, <code class=\"language-text\">key</code>, <code class=\"language-text\">left</code>, <code class=\"language-text\">right</code> and <code class=\"language-text\">p</code> (the parent).</li>\n<li>By the properties that we list next, the tree has the longest path to the leaves at most twice as long as the shortest path. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 570px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7aa18476042dde7d558d8e47fcd48752/432e7/8f8261513a3f90d8d301f970a77c24b05ccc9955.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABV0lEQVQoz11Sa6sBURT1//+CLySfzC3JfBbJEKEMMRIiBoO839a1Vh3Nvbt2e5999lpnP07k/X6DQvt8PmHOlNfrJaW4rosgCHA+n3E8HmUptLfb7YuL0DEgQ7xcLnE4HL6x2/2OeDwuQiMkyuVyuFwuCBcVMQmLxQJWKiV/NpvJ9noe7GwWYVmtVrp/PB6wbVvFFAoFqSq8Xq/o9/sfcA/tdhuZTAaVSgWWZaHRaMDzPMVKJQeJRALrdYD9fo9kMvkpwhdJvV6XipCtWNYPYrEYdrsdqtUqJpOJHiEZ50OfsWazKdB0OoXjOHBbLZxOJ+HYugiZtN1ulTQcDtUS58NExmnNgsJtbzYb5Y/HY+V9l8IKeOn7PgaDgdosl8uaST6fR7FY1Cii0Sg6nQ663S5qtZp8zv3+WZhZyJ+lhLfMufJrEDCfz/VYOp3GaDRSe/xe/zGmwl8cplKCa1MCGAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8f8261513a3f90d8d301f970a77c24b05ccc9955.png\"\n        title=\"8f8261513a3f90d8d301f970a77c24b05ccc9955.png\"\n        src=\"/static/7aa18476042dde7d558d8e47fcd48752/432e7/8f8261513a3f90d8d301f970a77c24b05ccc9955.png\"\n        srcset=\"/static/7aa18476042dde7d558d8e47fcd48752/04472/8f8261513a3f90d8d301f970a77c24b05ccc9955.png 170w,\n/static/7aa18476042dde7d558d8e47fcd48752/9f933/8f8261513a3f90d8d301f970a77c24b05ccc9955.png 340w,\n/static/7aa18476042dde7d558d8e47fcd48752/432e7/8f8261513a3f90d8d301f970a77c24b05ccc9955.png 570w\"\n        sizes=\"(max-width: 570px) 100vw, 570px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>A red-black tree: the nil entry is a sentinel used as parent of the root and has child of all the internal leaves. It is always black. Allows for easier implementation and handling of the limit cases. </em></p>\n<ul>\n<li>Properties 2 and 4 and 5 allows the tree to stay balanced. We know that any simple path will contain a mix of black and red nodes. Assume these are all blacks. Then if another path exists, this (property 5) must have as many black nodes. If there are red nodes this need to be interleaved to black nodes, because they cannot have another red node as child or parent (by property 4).  There cannot be more than this amount, therefore the longest path is no more then than twice the shortest path:</li>\n<li>To deal with boundary conditions in red-black tree code, we use a common root and leaves element which is NIL. This sentinel node has all the properties as with a normal node. Its color attribute is BLACK. </li>\n<li>We call the number of black nodes on any simple path from, but not including, a node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> down to a leaf the black-height of the node denoted by <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\text{bh}(x)\"></img>. </li>\n</ul>\n<h3>Red-Black Tree height</h3>\n<p>A red-black tree with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> internal nodes has height at most <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2\\log(n + 1)\"></img>. This guarantees that all the operations that we perform an binary search trees are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log n\"></img> and we do not have to worry about the tree being unbalanced.</p>\n<p>Proof</p>\n<p>We start showing that the subtree rooted at any node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> contains at least <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^{\\text{bh}(x)} - 1\"></img> internal nodes.</p>\n<ul>\n<li>Base case: a leaf node has height = 0. The number of internal nodes is then <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^0 -1 = 1- 1 = 0.\"></img></li>\n<li>Induction: a subtree contains as many internal nodes as the sum of the internal nodes of the child subtrees. </li>\n</ul>\n<p>This is already telling use the the tree is “bushy”. As each left and right subtree have the same number of black nodes, they are equally “dense”.  </p>\n<ul>\n<li>Using property 4: at least half of the nodes in a simple path must be black. There cannot be less otherwise we would be forced to connect two red nodes.</li>\n<li>The length of  a simple path from the root to the leaves is equal to the height of the tree <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h.\"></img></li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\text{bh}(\\text{root})\"></img> (number of black nodes from the root) <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\geq h/2\"></img> (half the length of the longest simple path == half of the height of the tree)</li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n \\geq 2^{\\text{bh(root)}}-1 \\geq 2^{h/2} - 1 \\Rightarrow h \\leq 2(\\log n + 1)\"></img>  </li>\n</ul>\n<h3>Operations on Red-Black trees</h3>\n<ul>\n<li>Operations on red black trees are very similar to the ones performed on usual binary trees. There is a lot more book-keeping involved to make sure that the properties 1-5 are satisfied.</li>\n<li>They rely on a subroutine <code class=\"language-text\">rotate_left</code> and <code class=\"language-text\">rotate_right</code> which allow to change the order of the nodes. They are complicated and do not add much on the algorithmic perspective. Would be hard to remember. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 661px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/37fd5eaae533f1375746497659e40708/0012b/d1523a91c086f72ad9af30b7d31550eeadb819e9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAAA/0lEQVQoz31R226DMAzl/38M8cQDL3SirKNQQGHcGsQtwctxm6irpllyYjv2OSeJdxwHvRry99q7/dVjcw/LsizUti3K7qAzeVneKMuuVNc1FUVBfd/TMs8OZF1XnrMEcAa8meYgCBjYsgkhqKoqA1qyI86yjMZxdICo+75P85OEAbdto67rqGkaSpKE1VjVUIBzxNgxqNTOg2maMgEUDka51s8rT9PEg7AoikzjJ8dxHFNyPtPH6USXyxcDwKFQa01hGFKe59wLItTcG+LtcCUUoUTe7ySlpGEYGUAaUuwgf7z3N0+hR4jm10d5WABkVSJWSv37yyCFqX13sf3MH1GAHfPiSCqeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"d1523a91c086f72ad9af30b7d31550eeadb819e9.png\"\n        title=\"d1523a91c086f72ad9af30b7d31550eeadb819e9.png\"\n        src=\"/static/37fd5eaae533f1375746497659e40708/0012b/d1523a91c086f72ad9af30b7d31550eeadb819e9.png\"\n        srcset=\"/static/37fd5eaae533f1375746497659e40708/04472/d1523a91c086f72ad9af30b7d31550eeadb819e9.png 170w,\n/static/37fd5eaae533f1375746497659e40708/9f933/d1523a91c086f72ad9af30b7d31550eeadb819e9.png 340w,\n/static/37fd5eaae533f1375746497659e40708/0012b/d1523a91c086f72ad9af30b7d31550eeadb819e9.png 661w\"\n        sizes=\"(max-width: 661px) 100vw, 661px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>Just as a reference: a visualization of the rotation algorithm. The binary-search-tree property is always fulfilled with the left child being larger than or equal to the parent and right child being greater than the parent. This operation is constant time as it involves a fixed amount of pointers assignments.   </em></p>","frontmatter":{"title":"Trees","description":"Array","image":{"childImageSharp":{"resize":{"src":"/static/08f4f4c6bcbc1862e2c9472159464443/c7a62/eb4977c34ff73aa58cf609b0fd0c1202e32e4abb.jpg","height":630,"width":1200}}}}}},"pageContext":{"slug":"/trees/","previousPost":{"title":"Tricks","slug":"/tricks/"},"nextPost":{"title":"Stacks and Queues","slug":"/stacks-and-queues/"}}},"staticQueryHashes":["3868140423","4085307986"]}