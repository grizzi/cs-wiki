{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/hash-table/","result":{"data":{"markdownRemark":{"html":"<h2>Dictionary</h2>\n<p>An abstract data type (ADT) which maintains a set of items, each with a key. It can</p>\n<ul>\n<li><code class=\"language-text\">insert(item)</code>: overwrite any existing key</li>\n<li><code class=\"language-text\">delete(item)</code></li>\n<li><code class=\"language-text\">search(key)</code> : return item with given key or report that it does not exist. </li>\n</ul>\n<h2>Hashing</h2>\n<p>Allows to search for a key in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>. Typical applications are databases, for example lookup of username : password (key, value) pairs, or machine: ip addresses and so forth.</p>\n<h3>Direct Access Table Approach</h3>\n<p>Store items in the array indexed by the key. If the key happen to be integers, we can just store them in a giant array. Searching for a key would be looking for arr[key]. There are some problems with this approach:</p>\n<ul>\n<li>Keys might not be non-negative integers</li>\n<li>We need to allocate a lot of memory. if the key are 64 bit integers, we need a 2^{64}  long array, of which most will be probably empty. </li>\n<li>Pre-hashing (when keys are not integers)</li>\n</ul>\n<p>Maps keys to non-negative integers. Any object is then represented as a sequence of bits. And this bits, can be represented as an integer. The ideal pre-hash function is a function such that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?f(x) = f(y) \\iff x = y \"></img>  . But for some simple functions this might not be always the case. </p>\n<ul>\n<li>Hashing (map keys to smaller table)</li>\n</ul>\n<p>If we can find a function mapping any type to an int, we are not reducing memory as we would need to store as many integers as all different values that we can store in a memory. The scope of hashing is to reduce the universe of all keys (integers) down to reasonable size <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m\"></img> for the table. That also means that the hash function will sometimes map two different integers to the same key in the table (hash table). This phenomenon is called collision and we solve it with chaining.</p>\n<h2>Dealing with Collisions</h2>\n<p>There are 2 ways for dealing with collisions:</p>\n<ul>\n<li>chaining: if multiple items map to the same hashed key, store them as a list (linked list for example)</li>\n<li>open addressing: store each items separately but create a mechanism that generate a new hash value if collision happens</li>\n</ul>\n<h2>Chaining</h2>\n<p>When multiple items map to the same key in the has table, then we store them as a linked list. But then, is this any better? In the worst case scenario, the hash function always maps different keys to the same key and therefore the access table becomes merely a single liked list that we have to traverse to find the specific item. This is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. When doing randomization we can prove that the hash function nicely distributes all the keys and the linked list store at each entry is actually constant in size. </p>\n<p>We make an unrealistic assumption which is not quite true but convenient for analysis and understanding why chaining works.</p>\n<hr>\n<p>Simple uniform hashing assumption</p>\n<p>Each key is equally likely to be hashed to any slot of the table, independent of where other keys’ hashing. Basically keys are mapped in a independently, identically distributed (uniform) manner.</p>\n<hr>\n<p>In this case the probability that we store one key at the specific location is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?1/m\"></img> and as we store <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> items, the expected length will be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n/m = \\alpha\"></img> (load factor of the table). If <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m = \\Theta(n)\"></img> the load factor will be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>.  </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/159fb/c10af7f62318157cb4e1ece42b0249414b55bb88.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACAklEQVQ4y31Tia7aQBDj/78PPVWFkgNCLnKTc5O49vKCeIh2pdFskh2v7ZnscL8DwwBME9Y8txnGPN51HVY9cy3jiMn3MbsuzO0G1wtwvcZIkgy3NEcYRpiXBbuVgDMLl7a1gCsLbeiZ3zZAw5xHEaokxtQPBBvhOCOBDM5ng6rWuRW7jkwaFrYE/d8yRkU16nuLugEaRlVJyIp5NhRm7LndnWBlWSLLMgx9bwsnMlReKcFmHhz57nQ6kVkI3zcILgaeNyOKGtR1hTRNCTph11JaR3ZhGJL6GSn90T6OYxue59HmFsu8oChytG3DnBDIZ12JW5ZaMkmSQOQsoEI35PSwoRYxrilvIcN1Xa03stLzDFxnwvE4ke0I1x0QBCFZX3G5XGztD4YKgeq2G5k+wB5roNdfX78I5MJxfaoJeC5FxBqBCVSknh4qf1obqDzUhWVZoGD0JDHP8zO2ZRkKzOV8uY7zBBbQFg/AAYffB8o9Wl/3+z0Zf7FBvq2VynUDVFScATEVk1dmW17I4lWNarTXuHVdazv8kyHZ6eaeQ/sJULO2jZeyvM4Y+XcUBa1gfnoohnbm3oCeDBkljc8OBzT8Y3I2LstyVN+XqN52WRKlv+dQvzfidT9NI/7Qv5AdjYLAdjbWNLCzES8o9dtI8ntH/8VQndQoRRx2ybvTqk8T8RfGEzZw/FI4bAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"c10af7f62318157cb4e1ece42b0249414b55bb88.png\"\n        title=\"c10af7f62318157cb4e1ece42b0249414b55bb88.png\"\n        src=\"/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/c5bb3/c10af7f62318157cb4e1ece42b0249414b55bb88.png\"\n        srcset=\"/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/04472/c10af7f62318157cb4e1ece42b0249414b55bb88.png 170w,\n/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/9f933/c10af7f62318157cb4e1ece42b0249414b55bb88.png 340w,\n/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/c5bb3/c10af7f62318157cb4e1ece42b0249414b55bb88.png 680w,\n/cs-wiki/static/10eacbdfa37ae144f725547fe1cd9e95/159fb/c10af7f62318157cb4e1ece42b0249414b55bb88.png 1019w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Hash Functions</h3>\n<ul>\n<li>Division method : <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h(k) = k \\text{ mod } m\"></img> . Is bad if k and m have some common factor. For example if keys are even and m is some power of 2. Then we will eventually use half of the table. In practice is good if m is prime and not very close to a power of 2 or a power of 10.</li>\n<li>Multiplication method : <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h(k) = [ak \\text{ mod } 2^w] >> (w-r)\"></img>, where:</li>\n</ul>\n<p>Typically a is odd an in between <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^{r-1}\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^r\"></img> to avoid biased patterns. As we can see in the diagram below, multiplications between integers, when seen as binary numbers is actually a nice reshuffling of the bits. The most of the reshuffling is happening is in the “central” area where all the sums overlaps. The product integer is always contained in a <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2w\"></img> bits. We can then compute the modulo with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^w\"></img> which corresponds to selecting the first w bits of the resulting number and out of this we select the first r bits, shifting right w-r bits. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/eac55/3bb69000d38537a56f041d2b450331e32fac1410.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABUUlEQVQ4y6VTu07EMBDM2Xk5thPnLrlwL6H7AQokoKKgoKJCFEg0iAaJT+BXKICG8qiQkLiOL2N9miAr5KTkGGlky9aOd3bXntcNiph5/wDHGhElxDLs4z4i3MmIIzgnJkRNHOFM7pqhhGBKNMQhUTj3W8GQhYDNAqvNaI9YEcfEGawr3G8VDmCppkSQFZzigRnEx8g2RVwvxBBNIGrggnUJHjj7AsyQ2bDRXb+rKINdXduqpvP86uYu7GutborNaEIsUbsJarkZpSAMDR4qWrL+Rd01BXsV933b1blUevGyWj89r74+zy8uj+hsGUbxPpqTwYlqdjvFCNRzl4RRZAuv08yY1/f1w9vH9+P17f3CBtMjGjV0YbrM5h8kUolG8yJYLyGq2zo9sNh8F87ZweGxODk9E1SGEWawbHw97jzC2gbcpQADp2Y5znaCgUBn/ABkaxgSplXeeAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3bb69000d38537a56f041d2b450331e32fac1410.png\"\n        title=\"3bb69000d38537a56f041d2b450331e32fac1410.png\"\n        src=\"/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/c5bb3/3bb69000d38537a56f041d2b450331e32fac1410.png\"\n        srcset=\"/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/04472/3bb69000d38537a56f041d2b450331e32fac1410.png 170w,\n/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/9f933/3bb69000d38537a56f041d2b450331e32fac1410.png 340w,\n/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/c5bb3/3bb69000d38537a56f041d2b450331e32fac1410.png 680w,\n/cs-wiki/static/85f3ff6e7b2b32109e3317ad657a60f4/eac55/3bb69000d38537a56f041d2b450331e32fac1410.png 887w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Universal hashing : <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h(k) = [(ak + b) \\text{ mod } p]\\ \\text{mod }m\"></img> where</li>\n</ul>\n<p>It turns out that for the worst case choice of parameters <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?b\"></img> different keys <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?k_1 \\neq k_2\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\text{Pr}_{a, b}(h(k_1) =h(k_2)) = 1/m\"></img>. This means that in the worst case, this hashing function would be similar, or better then uniform hashing. A key is assigned to each slot in the hash table with probability uniform to the numbers of slots. The expected search operation is then <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1 + \\alpha) = O(1 + n/m) = O(1)\"></img> when the last equality holds if <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m = \\Theta(n)\"></img>.</p>\n<h3>How to choose m?</h3>\n<p>We would like <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m \"></img> to be at least as <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> but:</p>\n<ul>\n<li>we do not know beforehand <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> so that we might start growing n more then m and the load factor becomes big enough that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1 + \\alpha) = O(n)\"></img> again</li>\n<li>we could have a huge hash table. But that’s the whole point: trying to remap the keys to a lower dimensional space and keep memory requirements low. </li>\n</ul>\n<p>Idea</p>\n<p>Start with a small m, e,g, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m=8 \"></img> and extend/shrink as necessary. when increasing or reducing the size of the table we have to:</p>\n<ul>\n<li>make table of size <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m'\"></img></li>\n<li>build a new hash function <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h'\"></img></li>\n<li>rehash (as we will have to go over all the elements <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> and entries in the table <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m\"></img> and to construct all the elements in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m'\"></img> the operation is worst case <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n + m + m')\"></img>)</li>\n</ul>\n<p>When we rebuild the hash table, we are incurring a <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> operation basically. But this is the same problem as we had for dynamic arrays. If we double every time the size, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m' = 2m\"></img> (table doubling) this operation is done over <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> insertions, only <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2n \"></img> times. Meaning the the total cost is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Sigma_{j=1}^{\\lfloor \\log_2 n \\rfloor} 2^j = n + 1 = O(n)\"></img>. The “average” or amortized cost over n operations is then <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)/n = O(1)\"></img>. With deletion, the problem is more subtle. If we shrink by half when <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex? m/2\"></img>  is full, the new hash table will be as big as the number of keys in the list (<img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m/2\"></img>). If after this deletion we insert a new key, value pair, we have to double it again. So when we live on the edge, we would shrink and resize continuously which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. The trick is to shrink the hash table to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m/2\"></img> when  only <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n \\leq m/4\"></img>. Then the amortized time becomes constant also for deletion <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>. </p>\n<h3>Rolling Hash</h3>\n<p>String matching</p>\n<p>Given two string <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t\"></img>, does <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> occur as a sub-string of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t\"></img>? A brute force approach consists in looping all first characters in the sting t and comparing a substring of length <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?|s|\"></img> starting at that index with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img>. Since comparison of strings work by comparing each character in the substring the naive approach results to be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(|s||t|)\"></img>. Can we do better? The idea is to replace string comparison with hash value comparison which is a <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img> operation.</p>\n<p>Rabin-Karp’s Rolling Hash</p>\n<p>Assume we have the rolling hash function, which is an ADT which can compute a new hash value for a new substring in constant time. As we traverse the string <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t\"></img> each new substring shares <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?|s|-1\"></img> elements with the previous sub-string. We can exploit this to compute a new hash value in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>. </p>\n<p>Assume that we are using the division method as hash function, with m being a random prime <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\geq |s|\"></img>. The rolling hash maintains a string <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> which supports the following functions:</p>\n<ul>\n<li><code class=\"language-text\">append(c)</code>: add a character to the end of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img></li>\n<li><code class=\"language-text\">skip(c)</code>: removes the first character, assuming c is the first character in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img></li>\n<li><code class=\"language-text\">hash()</code>: returns the hash value of the current string</li>\n</ul>\n<p>If these operations can all be done in constant time, the whole hash update can take constant time.  Assume that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p = m\"></img> is a big random prime. Lets treat the string as a multi-digit number expressed in base equal to the size of the alphabet. Namely, given each character <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?c\"></img> in the alphabet of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> characters we have</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?H(\\text{x}) = H([c_{|x|-1}, c_{|x|-2}, \\dots, c_1, c_0) = \\Sigma_{j=0}^{|x|-1} c_j a^j\"></div>\n<p>where <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> is the size of the alphabet, and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?|x|\"></img> the size of the string. Then appending is the same as multiplying <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> with a and adding the number (order) associated to that character. If we want to do the skip, we want to remove the first entry which corresponds to the highest order term. </p>\n<p>Example</p>\n<p>Let’s use Rabin-Karp’s rolling hash to hash the alphabet. Here, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> will be 26, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?k\"></img> will be 33, and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?c\"></img> will represent the place in the alphabet where the character appears—so for “a” <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?c\"></img> will be 1, and for “z” <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?c\"></img> will be 26. It is better not to map “a” to 0 otherwise all strings “a”, “aa”, “aaa” and so forth would map to 0. Lets find the hash of “abc” and use that to find the hash of “bcd”:  </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?H(\\text{abc}) = 1  \\times 26^2 + 2 \\times 26^1 + 3 \\times 26^0 \"></div>\n<p>To get the hash of “bcd”, we need to remove “a” and add “d”. To remove “a”:</p>\n<div class=\"block-equation-container\"><img 1=\"\" src=\"https://latex.codecogs.com/svg.latex?H(bc) = 2 \\times 26^1 + 3 \\times 26^0 = H(\\text{\" abc\"})=\"\" -=\"\" \\times=\"\" 26^2\"=\"\"></div>\n<p>Now we need to shift everything to the left, to make space for d, prepended to the string “bc”. It is sufficient to multiply by 26 and add the encoding for d (4):</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?H(\\text{bcd}) = 26 \\times (2 \\times 26^1 + 3 \\times 26^0) + 4 * 26 ^0 = 2 \\times 26^2 + 3 \\times 26^1 + 4 * 26 ^0 \"></div>\n<p>In general therefore the skip step is implemented subtracting the highest value, which is the character encoding <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\times\"></img> <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a^{|u|-1}\"></img> (in our case for example, the lenght of the substring to find is 2). In the append step instead, we multiply all the string by <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> (shift to the left) and add the character value which will fill up the “empty space” at the right</p>\n<p>Rolling Hash Summary</p>\n<p>To recap the most important functions of the Rolling Ash ADT:</p>\n<ul>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\text{append}(c): x \\leftarrow a \\cdot x + \\text{base}_a  c\"></img></li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\text{skip}(c): x \\leftarrow x -\\text{base}_ac \\cdot a^{|x|-1} \"></img></li>\n<li>Implementation: when we use division hashing, we always compute <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x \\text{ mod }p\"></img> so we can reuse recursively some computation Using the properties</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">rt <span class=\"token operator\">=</span> RollingHash<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># rolling hash used for t</span>\nrs <span class=\"token operator\">=</span> RollingHash<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># rolling hash used for s</span>\n\n<span class=\"token comment\"># compute hash for s (does not change)</span>\n<span class=\"token keyword\">for</span> c ni s<span class=\"token punctuation\">:</span> \n    rs<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># compute hash function of the first |s| character in t</span>\n<span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> t<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> \n    rt<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> rs<span class=\"token punctuation\">.</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rt<span class=\"token punctuation\">.</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"We are done!\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    rt<span class=\"token punctuation\">,</span>skip<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  \trt<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> rs<span class=\"token punctuation\">.</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> rt<span class=\"token punctuation\">.</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> \n        <span class=\"token keyword\">if</span> s <span class=\"token operator\">==</span> t<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># there can be collisions in the hash table  </span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"We are done!\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># O(s) time required for char by char comparison</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You designed a good hash function! We are hear with a probability of 1/|s|.\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The complexity here becomes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(|t| + |s| + \\text{\\#matches}\\cdot |s|)\"></img></p>\n<h2>Open Addressing</h2>\n<p>We have talked of linked lists and and array to implement an hash table. We will see that an array is sufficient to implement an hash table and this is the notion of open addressing. If we had no collisions, an array would work. This is the reason why we used chaining, with linked lists.  Assume the array has length <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m\\text{ (\\# slots)} \\geq n\"></img>. So we have at most one element per entry and we cannot use chaining to store more then one element in each entry. </p>\n<h3>Probing</h3>\n<p>We are going to try to insert an item in the table, and if we fail, we will try to compute a slightly different hash for the key, value pair we are trying to insert. What we need, is a new hash function which specifies the order of slots to probe for a key (for insert/search/delete). Our hash function is going to take the universe of keys and a trial count (integer of failed attempts)  </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?h: \\underbrace{\\mathcal{U}}_{\\text{universe of keys}} \\times \\underbrace{\\{1, \\dots, m-1\\}}_{\\text{trials}} \\rightarrow \\underbrace{\\{1, \\dots, m-1\\}}_{\\text{hash value}} \"></div>\n<p>We would like <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?[h(k, 1), h(k, 2), \\dots, h(k, m-1)]\"></img> to be a permutation of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?[0, 1, \\dots, m-1]\"></img> such that we can always try for a new slot. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 414px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/cs-wiki/static/13635da62842bf7c4018026ce2cd9ca3/b910a/0147daec82e0c57138ba39ffc1e46bdc0785220d.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABtElEQVQ4y5WTe0+DMBTF9/2/kUb/MUZNTEyMbswhDhEoUyh9wNTxON6Wx+aiLjZpLinlxz3ntBP8Mdq2HZ+rqkJd199q0zRmE9q+mjH5DTTA2qpB5EXgeQ4pJbTWUEohTVPktGb3bD/EZPzQ/mln9ut13YAFCYQQFjSdTi3ITM4z4OkJ7eUlELxsO9yVtj9SUYKFKwvUPTDjnICcgBzYbNDSOj4/O+AAE5HAm/eGxEnAZgwizCHKDyj9jlcC5iK3HRqIrVnWAWk0vex2V3J0F8E7f8TD6RzemYvn2xB+QrJkiSRMrESlJBau28vlnWTGgLt74DX93qHpanm1xCPBfKovDgPjGkKuyUMGSbCCAokXCygKx1hgoFnoIXHvEfsONpT8CAxuAjyczDE7msE5drCaU1ck2QtSxM8M5brEuiyxJGBRFDZtA137HvLrCwjfRWMkD+arlSIfKT3yTsYCRVaQL93PVhGFIruUozgevbQeSgokJtlKH055WOcZ7z1UY3fZoVB+OofDO+PfABwO9y7wXzelet90KYst0FQDNHNf4UFgQ1dPS01ddXKHacAlhbQP/AKiK+rQKAA2egAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0147daec82e0c57138ba39ffc1e46bdc0785220d.png\"\n        title=\"0147daec82e0c57138ba39ffc1e46bdc0785220d.png\"\n        src=\"/cs-wiki/static/13635da62842bf7c4018026ce2cd9ca3/b910a/0147daec82e0c57138ba39ffc1e46bdc0785220d.png\"\n        srcset=\"/cs-wiki/static/13635da62842bf7c4018026ce2cd9ca3/04472/0147daec82e0c57138ba39ffc1e46bdc0785220d.png 170w,\n/cs-wiki/static/13635da62842bf7c4018026ce2cd9ca3/9f933/0147daec82e0c57138ba39ffc1e46bdc0785220d.png 340w,\n/cs-wiki/static/13635da62842bf7c4018026ce2cd9ca3/b910a/0147daec82e0c57138ba39ffc1e46bdc0785220d.png 414w\"\n        sizes=\"(max-width: 414px) 100vw, 414px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>We keep increasing the failure count and recompute a new hash until we find an empty slot.</em></p>\n<ul>\n<li>insert(k, v): keep probing until an empty slot is found (e.g none flag found). Insert them when found.</li>\n<li>search(k): keep probing, get a key, value pair and if the key is different, increase the trial count until either we find the key (key found) or we find an empty slot (failed search).</li>\n</ul>\n<p>What if in the previous example we delete 586 and search for key 496? When probing, we will encounter none in the second failed trial and the key, value stored there is now none, and so we will decide that 496 is not in the table (incorrectly). We need to implement a more advanced delete technique. </p>\n<p>Idea: replace the none flag with a delete me flag. </p>\n<ul>\n<li>During insert the delete me is treated as none  → insert deletes key, values when they are not needed anymore by overwriting them.</li>\n<li>During the search, if we find a delete me flag we keep going </li>\n</ul>\n<h3>Probing Strategies</h3>\n<ul>\n<li>Linear Probing : <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h(k, i) = (h'(k) + i) \\text{ mod } m\"></img></li>\n</ul>\n<p>This function satisfies permutation as given the same k and multiple trials, we will generate different slots in the range {0. ..., m-1}. The problem with linear probing, is that when we fail we will try on the next block and so forth, creating clusters of occupied cells and therefore failing to spread data around the table.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 296px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/cs-wiki/static/7d8ca815f6f31abcc2fbad2645e1fa2d/b1a44/f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACbklEQVQ4y5VU22oTURTN53mhtAVTwfbBPuhLH3zxE0S0hYiFCuKDv6DggyWm+hBEqGDakKRemuY2Eydzv2Xus9zn1FwmsbU5sDh7mHMW6+y99s7hkpWm6XiPoghhGI4x+p4+w1buKoSO46DX60FRFAwGAw5ZliH0BXQabQRuOD5/JULbtiGKIjRN46QMLBZEAVJXQhIl/yaclj/CiFAQhDnCbrcLy7Iyd3IXqZp7Ml1W6ZnyQIIsSTzutNsZwr85TDOKeAHiBF4QwfNDaLaH/kCFpOmw/ADG0ONgcV/VYDt2VuGUoPFiKbGHAYIwgm776MsaKi/3cLTzGEeFbcJTVJ9t48uTRxC7Ar+TJMlEoWWavGqarsPQNYi/BzBtFzEpdb0QsmbgYOs+iqvXUby9guLaMkqEt6s3cfr9VyZFnLDRqOPw8CuOq1VKfg/tXh+a6cInhbLhQpBUfHr4AB/W8yhtrqN09w4+Et5trKH1swnHdWGSqLEPa7UqyuUyThonqNXrkBQdrh/DD0Ko1pA/mRGWNvI4GBFuTggtyqNhGBPC1tkZkdbA0pkmMYZUDPZURqiY5wpLW/fwfvka9vPL2L+1hGJ+CW9WbqD543T2yfOW8anCpuvzXbU8iFTlb69fobJbQGXvOcfxi118Luyg0+rOFGXGMvwn7SHlL4xinkeFLKOSuT367cYxh0dnFMvmHr20l9OMj85jly6J1Ck6dYdGXaISWCz8r1Mubj2Ht56qqtxeDCxmrcfacuFpMxoOOvmUETHolAY2gXRVp+GQLjZtXPIZU8iUZcaX2EO/KWKoe4sRprxI4RyCIJg7+wctjEiNMI5V/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png\"\n        title=\"f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png\"\n        src=\"/cs-wiki/static/7d8ca815f6f31abcc2fbad2645e1fa2d/b1a44/f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png\"\n        srcset=\"/cs-wiki/static/7d8ca815f6f31abcc2fbad2645e1fa2d/04472/f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png 170w,\n/cs-wiki/static/7d8ca815f6f31abcc2fbad2645e1fa2d/b1a44/f2a22e0bb96fef8d0738aff1bd6b84eb414d953a.png 296w\"\n        sizes=\"(max-width: 296px) 100vw, 296px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>Assume that h(k) = 45 is occupied. Then h(k+ 1) = 46, h(k+2) = 47 and so forth, and if all these are occupied, we will eventually append the key value pair to the cluster, and this will get bigger and bigger.  </em></p>\n<p>Probabilistically <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?0.01 < \\alpha < 0.99 \\Rightarrow \\text{cluster size is }\\Theta(\\lg n)\"></img> even though h is the perfect hash function. This means that search and insert are not going to be constant time anymore (we have to go through all the elements in the cluster which is  <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Theta(\\lg n)\"></img> long).</p>\n<h3>Double hashing</h3>\n<ul>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h(k, i) = (h_1(k) + ih_2(k))\\text{ mod }m\"></img></li>\n</ul>","frontmatter":{"title":"Hash Table","description":"The answer for your interview question might lie here."}}},"pageContext":{"slug":"/hash-table/","previousPost":{"title":"Heaps","slug":"/heaps/"},"nextPost":{"title":"Graphs","slug":"/graphs/"}}},"staticQueryHashes":["3868140423","4085307986"]}