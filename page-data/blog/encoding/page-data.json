{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/encoding/","result":{"data":{"markdownRemark":{"html":"<h2>ASCII Encoding</h2>\n<ul>\n<li>The ASCII encoding stores the alphabet and other human readable symbols (including white space) in a single byte.</li>\n<li>ASCII was originally developed for basic computers and printers. It uses a 7-bit  meaning that we have <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2^7 = 128\"></img> combinations (characters) at our disposalcode to represent characters.</li>\n<li>As more computers began to work with 8-bit groups of data, ASCII was written as 8 bits. The most significant bit was sometimes used as a parity bit to perform a parity check (a form of error checking). Other computers set the most significant bit to 0.</li>\n<li>A character set or charset is the set of characters that can be encoded. The ASCII encoding encompasses a charset of 128 characters. </li>\n</ul>\n<h2>Unicode</h2>\n<ul>\n<li>ASCII was not enough to encode more symbols like é, ß, ü, ä, ö or å</li>\n<li>This is where UNICODE comes into play, an alternative larger encoding that could unify all symbols used in human languages.</li>\n<li>In Unicode, a letter maps to something called a code point which is still just a theoretical concept. How that code point is represented in memory or on disk is a whole nuther story. Every platonic letter in every alphabet is assigned a magic number by the Unicode consortium which is written like this: U+0639.  This magic number is called a code point. The U+ means “Unicode” and the numbers are hexadecimal. U+0639 is the Arabic letter Ain. The English letter A would be U+0041. You can find them all using the charmap visiting <a href=\"http://www.unicode.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the Unicode web site</a>.</li>\n<li>The standard Unicode defines a huge table of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?1,114,112\"></img> code points that can be used for all sorts of letters and symbols. </li>\n<li>8 bits are not sufficient to store the value corresponding to a specific character. We need something like 3 bytes. Often these are rounded to 4 as this works better on modern machines.</li>\n<li>On the other hand if a character is using only the first 8 bits, we would always end up storing the first zero entries and waste a lot of memory. Therefore there are versions of unicode with variable memory allocations</li>\n<li>UTF-32 is such an encoding that encodes all Unicode code points using 32 bits. That is, four bytes per character. It's very simple, but often wastes a lot of space. UTF-16 and UTF-8 are variable-length encodings. If a character can be represented using a single byte (because its code point is a very small number), UTF-8 will encode it with a single byte. If it requires two bytes, it will use two bytes and so on. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 660px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cd30e8fc9e0f15e741602dbd77dfa27a/1f083/6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.705882352941174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABLklEQVQoz32SjY6EIAyEff/XdF3+UaOiItrroHju3eVImjYBpl8HqmVZaBgGCiFQjJGmaaK+7yntO2Edx/ErP6Ms3Nu2jSpcFlKQ9z4L1XVNr9eLIm/+J1DWuq4EKCFEhqrmeb43A3cx1mbSD7EfhCCJccvZ8vmmaUgbfRJCMKV0C+IA8D9pvgn3PZE1hqeSZDhjMmQEQKoQZj50+hUCCzqb0TGGFJIUX7TW5UZGG3LOkedQWucaoZRiwktwHMeMegqGfBFiaLLxWIn3lnVhAk3vtyBnT0Ep1SnuuWbBmxDjlZFROx4Bgn+ZXx4AQvpBiPoWxJeBwUUQ5mZqboKMgC0z04crHE8BQojADgFrlC4ehpsQD9Tx18kkHIY728v4p4dd13H21LbtVbt8BoJfofa3+6tAY2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png\"\n        title=\"6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png\"\n        src=\"/static/cd30e8fc9e0f15e741602dbd77dfa27a/1f083/6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png\"\n        srcset=\"/static/cd30e8fc9e0f15e741602dbd77dfa27a/04472/6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png 170w,\n/static/cd30e8fc9e0f15e741602dbd77dfa27a/9f933/6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png 340w,\n/static/cd30e8fc9e0f15e741602dbd77dfa27a/1f083/6dd4d541f0710e54c51a053ccebc6e3b17e7aeb5.png 660w\"\n        sizes=\"(max-width: 660px) 100vw, 660px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>As in UTF-8 the asian character does not fit into the byte, this is extended to accomodate more bits. Notice though, that the encoding is different, when using UTF-16 and UTF-32. It is just another way of mapping this big table of characters to bits when different number of bits are used to represent them.  </em></p>\n<h2>Misc</h2>\n<ul>\n<li>The program you're opening it with may decide to silently discard any bytes that aren't valid in the chosen encoding, or possibly replace them with <code class=\"language-text\">?</code>. There's also the \"Unicode replacement character\" � (U+FFFD) which a program may decide to insert for any character it couldn't decode correctly when trying to handle Unicode.</li>\n<li>We might get garbage values in the following situation. Assume that we store the character 縧 in the encoding GB18030 which is <code class=\"language-text\">10111111 01101100</code> and we read it with UTF-32 encoding which would be } (just saying, maybe its another one). If we try to save } in another encoding say,  LATIN-1 this will save the binary sequence that corresponds to } and we would have completely lost the original one. </li>\n</ul>\n<h2>UTF-8 and ASCII</h2>\n<ul>\n<li>UTF-8 is binary compatible with ASCII: all characters available in the ASCII encoding only take up a single yte in UTF-8 and the are exact the same bytes in UTF-8. </li>\n</ul>","frontmatter":{"title":"Encoding","description":"ASCII vs UTF, explained"}}},"pageContext":{"slug":"/encoding/","previousPost":{"title":"Graphs","slug":"/graphs/"},"nextPost":{"title":"Disjoint Sets","slug":"/disjoint-sets/"}}},"staticQueryHashes":["3868140423","4085307986"]}