{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/linked-lists/","result":{"data":{"markdownRemark":{"html":"<p>Lists of elements. Each element contains, a key (the value) and a pointer pointing to the next node in the list. In the following example, the last node has just a null pointer. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 415px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/20a73048bccdb149607538e7317fd1c7/73926/9d0e6876e30d1582ee96655093f5daf5aab6c602.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.05882352941176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABaElEQVQoz41Sa3OCMBDk//+7joN2eIk8LIhgxCcIbLOnoWD7oTdkSLK5ze1erL7rsU23CNeh/Gcx6K8f5G/mssZk/sIMbnFyOV+wL/aoVQ1VKZxPZ7RNi+7RSTIvNXOef7SPJ4kO7hM35Ja50QQPsNLAC7AJN8i+MjifDuyFPSrxHA9JlCCOYiztJXzPH6u2TKm8hcNUtMt3QnaqT4g2EXzXx1EdZZ8XlUWJqqwQ+AHSJP0hHH2Y+IZ50f+KUTIX9DDbZuIjgfvtjjzLZc1DrIQSaQcxVkSfqYQqiryYNEWHkZLGKZRSo3fcP1QHeK4nvtXHWsjWwVowniFG2TPJNHrxsRCvGLfrDcWugOu4QkQSIdWDlyZxgtVyJXlSiMZnXeYzuF6uImdKyK4SUweFKIwEJ8bulvsSzb0Rucaqp4fvTRieXWYyyYynTOac75Nr8zZZSNM0OkmnDi/J7+NX1/96AW+FkIzrb3OkURPJimUuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9d0e6876e30d1582ee96655093f5daf5aab6c602.png\"\n        title=\"9d0e6876e30d1582ee96655093f5daf5aab6c602.png\"\n        src=\"/static/20a73048bccdb149607538e7317fd1c7/73926/9d0e6876e30d1582ee96655093f5daf5aab6c602.png\"\n        srcset=\"/static/20a73048bccdb149607538e7317fd1c7/04472/9d0e6876e30d1582ee96655093f5daf5aab6c602.png 170w,\n/static/20a73048bccdb149607538e7317fd1c7/9f933/9d0e6876e30d1582ee96655093f5daf5aab6c602.png 340w,\n/static/20a73048bccdb149607538e7317fd1c7/73926/9d0e6876e30d1582ee96655093f5daf5aab6c602.png 415w\"\n        sizes=\"(max-width: 415px) 100vw, 415px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th><strong>API method</strong></th>\n<th><strong>Complexity</strong></th>\n<th><strong>Description</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">push_front(key)</code></td>\n<td>O(1)</td>\n<td>Reset the head pointer to the new key pointer and the new element pointer to the previously first element in the list.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">key top_front()</code></td>\n<td>O(1)</td>\n<td>Just dereference first pointer</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pop_front()</code></td>\n<td>O(1)</td>\n<td>Reset the head pointer to the one the first element is pointing to. Free the first element memory.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">push_back(key)</code></td>\n<td>O(n), O(1) with tail pointer</td>\n<td>In the most trivial implementation, we have to walk all the way down the list until we hit the null pointer. At this point we can add the new element. If we have a <strong>tail pointer</strong> pointing to the tail, than we know what is the last element.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pop_back()</code></td>\n<td>O(n), O(n)</td>\n<td>We need to walk all the way down the list to know which element is the last and free that up. This does not change when we have the tail pointer. Since the new tail needs to point to the previous elements, pointers do not help us to know what is the parent node and therefore we need to way until the end of the list.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">bool find(key)</code></td>\n<td>O(n)</td>\n<td>Need to traverse all the list</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">erase(key)</code></td>\n<td>O(n)</td>\n<td>Need to traverse all the list</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">bool empty()</code></td>\n<td>O(1)</td>\n<td>Check that head â‰  null pointer</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">add_after(node, key)</code></td>\n<td>O(1)</td>\n<td>Set the node pointer to the new node pointer and that to the next in the node pointer.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">add_before(node, key)</code></td>\n<td>O(n)</td>\n<td>Same as pop_back. We have no way to go to the previous pointer. So we have to walk all the way until we find the node and then perform an insertion setting correctly the pointers of the previous and new node.</td>\n</tr>\n</tbody>\n</table>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 491px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/33cc38baf1e8e1241e6b84ef8314881c/13566/12c67c19ecd468362ef5034371b57e5235736837.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.05882352941176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABQUlEQVQoz5VSi3KCQAy8//+/jtae8pD3SwQFUXDLRmDA0s40M+HuyGSz2UQ97g+EQYgoiOB7PpI4QXWtQHt2z/6Df7nq2g6BH+BoH2GbNjzHQ57lEiSggHZDwvu5Bkgml/ICx3ZeDKNEgG/1bQk6JIzvuc//K3m0QwArVbEEmmx+nRWUlsuiRJZmqKta2KZJiqZuhGUcxWhuzZR8zs/i7aOVMz8t5VEciuu40F9aghyQc3QEVO80tputJBI89EPsPneT5puPjeT+ALQMS3Sj8R14AfZ6jyiMJME0TJyyk3TATizTwkEfYBwMpHG6kEHNdaLfm7swJSO2yonLgAajPIx77msbWHC8Uz7118TW/vHOXWXbIxkCkjV1VWuJ7wCLszeyooY0sqIcHB67U/P9+m3PFkV748Co5bgylKA4FwL+DdsVVwQvjVCYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"12c67c19ecd468362ef5034371b57e5235736837.png\"\n        title=\"12c67c19ecd468362ef5034371b57e5235736837.png\"\n        src=\"/static/33cc38baf1e8e1241e6b84ef8314881c/13566/12c67c19ecd468362ef5034371b57e5235736837.png\"\n        srcset=\"/static/33cc38baf1e8e1241e6b84ef8314881c/04472/12c67c19ecd468362ef5034371b57e5235736837.png 170w,\n/static/33cc38baf1e8e1241e6b84ef8314881c/9f933/12c67c19ecd468362ef5034371b57e5235736837.png 340w,\n/static/33cc38baf1e8e1241e6b84ef8314881c/13566/12c67c19ecd468362ef5034371b57e5235736837.png 491w\"\n        sizes=\"(max-width: 491px) 100vw, 491px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>With a tail pointer, we know which is the last key and pushing back means just setting that node pointer to the new element and updating the tail to point to the new appended node (in the figure the tail is not yet updated to pointing to the last node)</em></p>\n<h3>Doubly-Linked List</h3>\n<p>The problem with the previous implementation is that there was only one direction of traversal. We add a second pointer to the previous element and so, we can traverse the list in both directions. We obtain a doubly-linked list.  </p>\n<ul>\n<li><code class=\"language-text\">pop_back()</code> becomes an <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img> operation as we can access the previous pointer. </li>\n<li><code class=\"language-text\">add_before()</code> also becomes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img></li>\n<li>With doubly-linked lists we get best performance but find and erase a specific key remains an <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> operation as we need to traverse the full lists to find the key. </li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 490px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/638e83dfb3633643823f76b72c88e5c3/41d3c/84e342b830c4230ddc31caa96ab5c5a0f50940a1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABh0lEQVQ4y5VTi5KCMAz0/3/wBNRD1ELLG3nJa4+Eo6Ijp5eZTEsgm2Q3bIZhABmdz/6pLXM2GLCa3HUd+r7n98uT4vP92TbLDouiQJqmqOsaURjhcr6gqiokcYLD/oC6qpEkCVzhMqjnetjv9sjSTOdpwLZt+YVzdOD7PieJi2C3LAs7awfHcXC0j/wNuW3bDEhxKp5l2R2waRpsv7acOBfwlQ/DMLhD6UnuMr/mDHo+nRHHMTdBoxMwFX8YuSxK5HnOz2VZ8tjUqWVaPB6BUkEqJISAaZiIogi32w1VWaFt2nVRiC9KJF6I2yAIJlrGseIoRt/1fKZJynEtygz4ymdll6tBNseXMb027/ZtbSeXsSXohi7Ej+e6CIOQiXbHO/FFYqwt/aufQAOSEFIFI08hk8w+CkKKPie8Mz2y6eUQnhpVFaujr/Py63fAAd/yCuWH436dWD2lFFOhpOId1aAD/nTdIQHS2MQlLSsBSil5dR4APx3ZEhmEO40cj2JMQk3L/J8OfwDVX48OWc/QqgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"84e342b830c4230ddc31caa96ab5c5a0f50940a1.png\"\n        title=\"84e342b830c4230ddc31caa96ab5c5a0f50940a1.png\"\n        src=\"/static/638e83dfb3633643823f76b72c88e5c3/41d3c/84e342b830c4230ddc31caa96ab5c5a0f50940a1.png\"\n        srcset=\"/static/638e83dfb3633643823f76b72c88e5c3/04472/84e342b830c4230ddc31caa96ab5c5a0f50940a1.png 170w,\n/static/638e83dfb3633643823f76b72c88e5c3/9f933/84e342b830c4230ddc31caa96ab5c5a0f50940a1.png 340w,\n/static/638e83dfb3633643823f76b72c88e5c3/41d3c/84e342b830c4230ddc31caa96ab5c5a0f50940a1.png 490w\"\n        sizes=\"(max-width: 490px) 100vw, 490px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Summary</h3>\n<ul>\n<li>Constant time to insert at or remove from the front</li>\n<li>With tail and doubly-linked, constant time to insert at or remove from the back</li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> time to find arbitrary element</li>\n<li>List elements need not to be contiguous</li>\n<li>With doubly-linked list, constant time to insert between nodes or remove a node</li>\n</ul>\n<h3>Array vs Lists</h3>\n<ul>\n<li>In general arrays are fast to read while lists are fast to write</li>\n<li>Arrays are specialized for random access. Get the key at a specific index is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img> operation</li>\n<li>Lists require all traversal to read a specific node (at an index, e.g the 10th node, or with a specific key)</li>\n<li>E.g with MERGE-SORT we need to merge two ordered sequences in one bigger ordered sequence</li>\n<li>In general lists are good for many insertions and deletions but as Mr Stroustrup tell us in <a href=\"https://www.youtube.com/watch?v=YQs6IC-vgmo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this talk</a> this is eventually not that true when we consider how programs are implemented:</li>\n</ul>","frontmatter":{"title":"Linked Lists","description":"Array","image":{"childImageSharp":{"resize":{"src":"/static/c619144143f213f47cb6a2cdff062d2d/c7a62/7f4398466afe2a85e0c559e155543afb3223cbc4.jpg","height":630,"width":1200}}}}}},"pageContext":{"slug":"/linked-lists/","previousPost":{"title":"Patterns","slug":"/patterns/"},"nextPost":{"title":"Introduction and Big O Notation","slug":"/introduction-and-big-o-notation/"}}},"staticQueryHashes":["3868140423","4085307986"]}