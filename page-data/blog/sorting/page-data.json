{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/sorting/","result":{"data":{"markdownRemark":{"html":"<p>The goal is to sort elements into a collection according to the value of their key. </p>\n<p>There is a class of sorting algorithms like insertion sort, merge sort, heap sort and quicksort that are comparison sorts: they determine the sorted order of an input array by comparing elements. It is possible to prove a lower bound on this class of algorithms which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Omega(n\\log n)\"></img>. Therefore algorithms like heap sort that are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n\\log n)\"></img> are asymptotically optimal, we cant do better with this method.</p>\n<p>We can beat this lower bound, if we ca gather information about the sorted order. The counting sort algorithm for example, assumes that the input is in the set <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\{0, 1, \\dots, k\\}\"></img> and takes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Theta(n+k)\"></img> time. If there is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> integers to sort, each integer has <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d\"></img> digits and each digit can take up to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?k\"></img> possbile values, the radix sort can sort the numbers in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Theta(d(n+k))\"></img>. A third algorithm, bucket sort, requires knowledge on the probabilistic distribution of numbers in the input array. </p>\n<h3>Applications</h3>\n<ul>\n<li>Compressing documents: we might have duplicate keys that can be found sorting them. Then we represent documents only with a unique reference and counter</li>\n<li>In computer graphics, scenes are represented by sorted layers, from bottom to the top ones. </li>\n</ul>\n<h3>Comparison Sort</h3>\n<ul>\n<li>Insertion Sort</li>\n<li>Bubble Sort </li>\n<li>Merge Sort</li>\n<li>Heapsort</li>\n<li>Quicksort</li>\n</ul>\n<h3>Insertion Sort</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 586px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fab68955b141719b10760e495afb80a2/a76f4/550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAAB1klEQVQ4y5WUWYvCQBCE8/9/iiLogwjiAYr64osH4n3gfZ94ay9fw6yJm7i7A8OkMzPV1dWVWPJhPJ9PXc/ns6xWKzkej/J4PBz7ZprY8gKyH1wul9JoNKTVakm/35fRaCTX6/XHeYb1F4b7/V7K5bKCAtbpdGQ+n8tisZDT6eQ4a71ftrNj3u93GQ6HEo/HJZlMSiqVkvF4LLVaTWUYDAZyOBxeJRugd+omrlQq0m63dQW4UChoHA6HZTabKeh0OvVmyLjdbrLZbHRSIiz8fr/kcjkFJu71elr2er1WxkZTy84KIA6USiVJJBJaHqVlMhmp1+sSi8Wk2WwqAOwApGHEu93uBcggAwegn8/npVgsKki321VWwWBQstmsNuFyuaiFAMFSvDPNsewNwBYw5BB+4x2J0M3n8+k+YDTKyxWOkrHBdrvVbDBgpaRAICCRSETS6bSCmWTv09EUmCE2JcOChhCjFdrRVUokiRuYAxBmCAsI2qEb4k8mE21IKBSSaDSqe3bPuQ2LznKRUvEZl2BWrVa/rQEI3uMLgf2vgHgNg/KdwpJnkryLb2IvMAUku3E8OsKSbpq/itsf5SNDSqUswwo97WCfPkvPkvEaK/5z+1n8Z3wBCUEWiMbvX9AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png\"\n        title=\"550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png\"\n        src=\"/static/fab68955b141719b10760e495afb80a2/a76f4/550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png\"\n        srcset=\"/static/fab68955b141719b10760e495afb80a2/04472/550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png 170w,\n/static/fab68955b141719b10760e495afb80a2/9f933/550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png 340w,\n/static/fab68955b141719b10760e495afb80a2/a76f4/550eafafa1e48a8ed66ab4925aacb8d0784e4ae0.png 586w\"\n        sizes=\"(max-width: 586px) 100vw, 586px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Insertion sort is an efficient algorithm for sorting a small number of elements. Insertion sort works the way many people sort a hand of playing cards. We start with an empty lfet hand and the cards face down the table. We then remove one card at a time from the table and insert it into the correct position in the left hand. To find the correct position for a card, we compare it with each of the cards already in the hand, from right to left. </p>\n<p>The algorithm sorts the input numbers in place: it rearranges the numbers withing the array. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">insertion_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>            <span class=\"token comment\"># n times</span>\n        key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n        i <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key<span class=\"token punctuation\">:</span>       <span class=\"token comment\"># move all elements greater then new key to the right O(n)</span>\n            a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            i <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key                      <span class=\"token comment\"># put the key at the right spot</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f61dc441990ab3962cd6916d23ecc1d4/1ac29/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.058823529411764%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA60lEQVQY022Qy4qDQBBF8/OKvyK4zMI/cOFCg+jCByJIJGJ8v4254daQYRZzF93UreqqU315v994vV7oug7LsmBdV2zbhq/PeBgGTNMkPj3mjuOQXN/3mOdZYurCojRNoSgKXNfF/X5HURRSUJYlHMeBpmmwLEt8Pmbzx+OBLMugqips28Y4jj8NeXwn/RUpqH3f0TTNvzmqbdtfOvpCSBLf9xFFEQzDwO12kwKuSuIgCBCGIXRdFyqu/Xw+hbKqKiFnYyE8zxN5nsPzPMRxDNM0kSSJJLleXdcygN71epUBJOEw/js3481a6gMUh3bpGFwuQgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png\"\n        title=\"8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png\"\n        src=\"/static/f61dc441990ab3962cd6916d23ecc1d4/c5bb3/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png\"\n        srcset=\"/static/f61dc441990ab3962cd6916d23ecc1d4/04472/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png 170w,\n/static/f61dc441990ab3962cd6916d23ecc1d4/9f933/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png 340w,\n/static/f61dc441990ab3962cd6916d23ecc1d4/c5bb3/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png 680w,\n/static/f61dc441990ab3962cd6916d23ecc1d4/b12f7/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png 1020w,\n/static/f61dc441990ab3962cd6916d23ecc1d4/1ac29/8e92e8f6423e883e9a0c1eb700f300c0e5f2b06b.png 1022w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Analysis</h3>\n<ul>\n<li>the outer loop executes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> times. </li>\n<li>the inner loop executes:</li>\n<li>The time complexity of the algorithm is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n^2)\"></img>.</li>\n</ul>\n<h3>Binary Insertion Sort</h3>\n<ul>\n<li>When analyzing these algorithms we are glossing over the constant time complexity of the comparison operator and swap operator . </li>\n<li>It can happen that the comparison operator is a overall way more complex subroutine than the swapping of simple pointers. Then in this case we could think of replacing the search for the index where the new element is insterted to be done through binary search which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(\\log i)\"></img> for iteration i. </li>\n<li>Even if we reduce the search time from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log n\"></img> we need to still shift over all the elements in the array to the next location (make space for the new element) which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img>. This version of insertion sort is called binary insertion sort</li>\n</ul>\n<h3>Bubble Sort</h3>\n<p>In bubble sort, we move all the elements from the end of the array to the front. They move like bubble to the surface. </p>\n<ul>\n<li>In the firs iteraction the smallest value moves the index 0, since this is compared agains all the elements in the array. </li>\n<li>In the second iteration, the current last value in the array is compared with the [1:n] elements (since now the minimum is at entry [0])</li>\n<li>In the third iteration, the current lst value in the array is compared with the [2:n] elements (since noew the first two minimum are at entries [0, 1]) and so forth</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"> <span class=\"token keyword\">def</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>         <span class=\"token comment\"># previous element is smaller </span>\n                swap<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> </code></pre></div>\n<h3>Analysis</h3>\n<ul>\n<li>We execute the first loop for <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> times</li>\n<li>For each of these iterations we perform additional comparisons and swap </li>\n<li>In total we do <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n + (n-1)+ (n-2) + \\dots + 1\"></img> operations for a total of time complexity of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n^2)\"></img>.</li>\n<li>In the best cases the array is already sorted and no swap is performed. If we do not count the comparison as an operation, than it is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img></li>\n</ul>\n<h3>Selection Sort</h3>\n<p>Selection sort is similar to bubble sort. It does <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> passes over the array, finds the current minimum and place it to the next position. At first pass finds the minimum and swap it with <code class=\"language-text\">a[0]</code>. At the second pass finds the minimum larger then <code class=\"language-text\">a[0]</code> and places it a <code class=\"language-text\">a[1]</code> and so forth...</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">selection_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n       min_key <span class=\"token operator\">=</span> inf\n\t\t\t min_idx <span class=\"token operator\">=</span> i\n       <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n           <span class=\"token keyword\">if</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_key<span class=\"token punctuation\">:</span>\n               min_key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n               min_idx <span class=\"token operator\">=</span> j\n       swap<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>min_idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\t</code></pre></div>\n<h3>Analysis</h3>\n<ul>\n<li>Similarly to the previous sorts, we do <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> comparison swiping over the elements in the array. The total complexity is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n^2)\"></img>.</li>\n</ul>\n<h3>Merge Sort</h3>\n<p>The key operation of the merge sort algorithm is the merging of two sorted sequences in the “combine” step. Merge-sort follows a divide-and-conquer approach. Recall that this method consists in solving problem of smaller size and combining their solutions in a single one.</p>\n<ul>\n<li>divide step: the n-element sequence is divided in two sub-sequences of n/2 elements</li>\n<li>conquer step: sort the two sub-sequences recursively using merge sort</li>\n<li>combine step: merge the two sub-sequences to produce the sorted answer  </li>\n</ul>\n<p>The merge sort exploits a subroutine called <code class=\"language-text\">merge</code> which takes two separately sorted sub-sequences and create a merged sorted sub-sequence within <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?T(n) = n\"></img>. It starts taking both cards on the left of the two sub-sequences and appending the lowest one. Then a new left card is taken, if the left was the smallest, or the right in the opposite case and the iteration continues until all card are placed.  </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e9fa7dd038cd128c7df9337345d002ae/33d1d/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABUUlEQVQoz41S68qCQBTs/d9IRME0hJCQSqjoYqlpqd3vZfN9c2Al+tWBZW+zc+bMngb+o6oqFEWBMAwxn8+xWCwwnU6RpilerxcheL/fgjscDoiiSHDEz2YzJElS4xoEMobDITRNg2EYMrjudrv4DBJut1s0m03oug7TNGX2fb9OKoSr1UqyZlmG6/WK+/2O5XIpmTmUuvV6Lep59ng8UJYlRqOR7FmNEJL5dDpht9vJ4JplbTYbUcO9quJ4PGK/39c4YkjGPe9qhb/ErzhRSEPzPMdkMkGr1YLrurAsC0EQSKmfn0Ic7eGd4ziwbRu9Xq9OKIS3203k0x8a3O/34XmeJKBXCkwcu4Fe07tOp4N2uy1r+k5hQsiL8XiMOI7xfD7FfCrgQ6pRhEw2GAykXS6Xi+DYEXxLHJMLIRfMQDKqOJ/PMqszRfiN48dw5lB9+Aco8aeHiUKkigAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png\"\n        title=\"ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png\"\n        src=\"/static/e9fa7dd038cd128c7df9337345d002ae/c5bb3/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png\"\n        srcset=\"/static/e9fa7dd038cd128c7df9337345d002ae/04472/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png 170w,\n/static/e9fa7dd038cd128c7df9337345d002ae/9f933/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png 340w,\n/static/e9fa7dd038cd128c7df9337345d002ae/c5bb3/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png 680w,\n/static/e9fa7dd038cd128c7df9337345d002ae/b12f7/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png 1020w,\n/static/e9fa7dd038cd128c7df9337345d002ae/33d1d/ac252a1fa69b3d2e4ed814c22ae8550dcd7b3722.png 1150w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>The figure shows the execution of the MERGE routine: we take the smallest “card”, once at a time from left or right, until we consumed the whole array.</em></p>\n<p>The <code class=\"language-text\">merge</code> algorithm takes the input array <code class=\"language-text\">a</code>,  the start <code class=\"language-text\">p</code>, intermediate <code class=\"language-text\">q</code> and final index <code class=\"language-text\">r</code> that represents the boundaries of the two subarray to merge. Note that the <code class=\"language-text\">merge</code> routine does not operate in place. Therfore for small problem sizes, better performance could be achieved with the <code class=\"language-text\">insertion_sort</code> being the latter, more efficient in terms of memory and space. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> array<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    l <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>p <span class=\"token punctuation\">:</span> q <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    r <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>q <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> r<span class=\"token punctuation\">]</span> \n    \n    <span class=\"token comment\"># insert some sentinel-cards at the end of the sub arrays</span>\n    l<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>inf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    r<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>inf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\ti <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    j <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> l<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> l<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\t\t\t\t<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n            j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>  </code></pre></div>\n<p>The procedure <code class=\"language-text\">merge_sort</code> takes an array and divides it into two smaller array which are solved recursively. All the actual load is on the combine step of the technique. In other words, we find a method that operates in smaller time but on more instances of a simpler problem (already sorted sub-sequences) and we hope to gain in this way efficiency. Notice that this is not always the case, for example when:</p>\n<ul>\n<li>the combine routine is as time-consuming as the initial problem or </li>\n<li>too many subproblems are created.  </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> Array<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> p <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> floor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">+</span>r<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        merge_sort<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">)</span>\n        merge_sort<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> q<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n        merge<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> </code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 655px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/63ae2868c922eecc3c4b03f28f4333d9/ae6b7/160feeb39e0c1afb198993a9d07898e5b37ecb87.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.70588235294117%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABdklEQVQ4y12Th44CMQxE8/+fBwJEFXXpdZdefPcsTc6cJW+yrpmJk+xXPp+Pa9y/329f1+u1TadTGw6Htlwus18x//OTDMjxeLR2u22dTsf6/b71ej1rNptWr9etVqtZo9FwO3602+3abrezWCPFDvf73Q6Hg51OJy8+Go1sv9/b9Xq12+3m+/F47GtZlh6D/euE2kQBSlVVGRKwV6tVPsn5fM6+KPiSCtCZE8EVsPlHH49H1tfrZZPJxGOATLxyns/nH2QKFkXhBbiA+XzuiYvFwgtJSMJHEdaYkwtGyMCMHEYoMQ7+iEPZf0HmA+mbzSaTrYLYLpdLLqg4FdLFbLdbj8uQB4OBtVotHwMJ46ERUvdo06XwTy4KbC/IieCLzhEWHOGLttls5jYuCAUVnJJLk6TXwCUwGurMHhuvQ68m2iTYaKKxSnQDsqDzz0mAh9AdfuBPNqghhksUJUCHz8SxRTxJ8ICN4RWXPEFW5g3BJ8iKk+0H0tXjWckEwq8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"160feeb39e0c1afb198993a9d07898e5b37ecb87.png\"\n        title=\"160feeb39e0c1afb198993a9d07898e5b37ecb87.png\"\n        src=\"/static/63ae2868c922eecc3c4b03f28f4333d9/ae6b7/160feeb39e0c1afb198993a9d07898e5b37ecb87.png\"\n        srcset=\"/static/63ae2868c922eecc3c4b03f28f4333d9/04472/160feeb39e0c1afb198993a9d07898e5b37ecb87.png 170w,\n/static/63ae2868c922eecc3c4b03f28f4333d9/9f933/160feeb39e0c1afb198993a9d07898e5b37ecb87.png 340w,\n/static/63ae2868c922eecc3c4b03f28f4333d9/ae6b7/160feeb39e0c1afb198993a9d07898e5b37ecb87.png 655w\"\n        sizes=\"(max-width: 655px) 100vw, 655px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Analysis</h3>\n<p>The running time of algorithms that contain a recurrence are often described by a recurrence equation. In the general case the problem is divided in </p>\n<ul>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> subproblems, where each subprolem processes a  smaller problem instance, </li>\n<li>dividing the original one by a factor of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?b\"></img>. </li>\n</ul>\n<p>In the trivial case (<img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n=1\"></img>) the problem often takes constant time (we write <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?T(1)\"></img>). In the other cases, the time depends on:</p>\n<ul>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?aT(n/b)\"></img>  : the time required to solve the <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a\"></img> smaller subproblems,</li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?D(n)\"></img> : the time required to divide the problem in subproblems,</li>\n<li><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?C(n)\"></img> : the time required to combine the solutions of each subproblem (e.g time of MERGE routine)\nTo recap:</li>\n</ul>\n<p>In our case we have that at each iteration we divide the original problem in 2 subproblems processing half the original vector → <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?a=2\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?b = 2\"></img>. The divide step is just a simple division, thus <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?D(n) = \\Theta(1)\"></img> and the combine step is the time taked by the <code class=\"language-text\">merge</code> routine which is linear in the number of elements of both subarrays, thus <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?C(n) = \\Theta(n)\"></img>. Overall the recursive equation reads:</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?T(n) = \\begin{cases}\nT(1) &amp;= \\Theta(1) \\\\\nT(n) &amp;= 2T(n/2) + \\Theta(1) + \\Theta(n) = 2T(n/2) + \\Theta(n) \n\\end{cases}\"></div>\n<p>Solving this recursion can be done with the master theorem. Intuitively, we reach the leaf nodes when <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n / 2^i = 1 \\Rightarrow i = \\log_2 n\"></img>. In other words there are <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2 n + 1\"></img> levels (considering the first vector). </p>\n<ul>\n<li>At each level the cost of computing the <code class=\"language-text\">merge</code> is  <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?c(n/2) + c(n/2) = c(n/4) + c(n/4) + c(n/4) + c(n/4) = ... = k c(n/k) = cn \"></img> . </li>\n<li>This total computation is performed as many times as the depth of the recursion tree which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2 n + 1\"></img>.</li>\n<li>The total time complexity of the algoritm will be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(\\log_2 n + 1)cn = \\Theta(n\\lg n) \"></img>. </li>\n</ul>\n<h3>Curoisity</h3>\n<ul>\n<li>There is a in place version of <code class=\"language-text\">merge_sort</code> that has less space complexity (not copying arrays over in the <code class=\"language-text\">merge</code> routine) but has proven impractical since it is quite slower. </li>\n</ul>\n<h3>Heapsort</h3>\n<p>Heapsort is a sorting algorithm that relies on th heap datastructure. It takes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n\\log n)\"></img> like merge sort but differently from this algorithm it orders the array in place, allowing for more optimization to occour.</p>\n<h3>Heap (Review)</h3>\n<ul>\n<li>The (binary) heap is a nearly complete binary tree. While it is generally stored as a contiguos array can be seen as a tree with the property that the parent is alwasy greate or equal than all its children (max-heap). The largest element in the heap is the heap root.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0b8feebc7069d1888b78193d931e5e5f/c4b7c/29e78bf8071d505f272aa9ec0542233d8edbc290.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.352941176470594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABPElEQVQoz5WSCYvCQAyF5///L1FbtCJ4i6iIxaPerdbruV9gXFi6ixtIM0lm3mTeq9OXPZ9Pc+x4PKrT6eh6vb7rn7jHcT7Jsky9Xk/3+93yNE3V7Xb1qXkcx2e/32u1Wul0Omm9XitJEi0WC8vjONblctF2u1Wr1bLpuajdbms0GtkQ9N4TshiPx5rP57rdbppOpwa42Wxs03K5tOl3u52azaaiKDJgAAEfDoc6HA7fgHAG4Gw202Qyscn8+I/Ho/B50PKz57l0RQfO5/OffOV5bqIVmYMfngcIG5mYGqJQI/JkIk+jj7OGe/iDDnLOO8BKpZLxg9dqNfMgCNRoNFStVhWGoXFXqVRULpetTp8eNSKOBo5b6vW6HUA9lOv3+0Y8hHunhwioSt9HnPpgMDBuHVzwqyDGb7z8x15TnvioQnMUUQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"29e78bf8071d505f272aa9ec0542233d8edbc290.png\"\n        title=\"29e78bf8071d505f272aa9ec0542233d8edbc290.png\"\n        src=\"/static/0b8feebc7069d1888b78193d931e5e5f/c5bb3/29e78bf8071d505f272aa9ec0542233d8edbc290.png\"\n        srcset=\"/static/0b8feebc7069d1888b78193d931e5e5f/04472/29e78bf8071d505f272aa9ec0542233d8edbc290.png 170w,\n/static/0b8feebc7069d1888b78193d931e5e5f/9f933/29e78bf8071d505f272aa9ec0542233d8edbc290.png 340w,\n/static/0b8feebc7069d1888b78193d931e5e5f/c5bb3/29e78bf8071d505f272aa9ec0542233d8edbc290.png 680w,\n/static/0b8feebc7069d1888b78193d931e5e5f/c4b7c/29e78bf8071d505f272aa9ec0542233d8edbc290.png 903w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>In order to maintain the heap property we rely on the <code class=\"language-text\">max_heapify</code> routine. The assumption is that the children of a node non satisfying the heap property are valid heaps. Then this node is exchanged recursively with the largest of the children nodes, until it moves down to the level where the heap property is satisfied. It can be shown that this routine’s time complexity is linear in the depth of the subtree to be process, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?h\"></img> that is  <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(h) = O(\\log n)\"></img>.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1785c5100f2860aff9f12837c76dc7bf/2a50c/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAB0klEQVQ4y52U12qDMQyF/f7vlLtALpKQBEL23nvvpfKpyLhuWkoNwrZ8LB0f6f/d6/USjGHz/X6X6/XqfeaP95fLRZ7P5xe/C4E2ZrOZDAYDic/CYI/HQzqdjmy32y84DWhZGo2G5HI5D5jP5zIej78l7Ha7st/vxe4S+HQ66d4ZkExcnk6nCt5sNmr4V6uVYo7HoyY9HA56xswZeJud0W+1WpoFXQi6XC51bUwZw+FQUqmUrsEQBByDu+v1+jMgC9hhk8lEM8eF4mkEWSwWikHnsHA2vIawxFjfbjfPzgqBGcZwJGYdBnVhdBtkNpFjBmFQjBaDADPmQhZkxdAMvYxJzDTEx3sXMkDgfr//th/jBv9p+CcjNm2BdlSPYLQMT2f9G9PQnGlGc1Ll3W6nwZmtivRcLP6PDK2peWoymdTWCKv3V2ae4buM1iL/GcoQzWAIUwqD4aPhWeNHAqrPjARoez6fvd6Y//T4PhOJhBQKBSkWi5LP5/UnwedYrVYlnU7rWTab1fNMJiOlUkl9lUpFZ3ztdvszING5jDWbTanX65oEMKBer6d9ySv407Avl8tSq9UUgx/faDQSh+iALSAGGCAsYBhehiFBTRLM/kwU8wM0lGqgYA1GmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png\"\n        title=\"cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png\"\n        src=\"/static/1785c5100f2860aff9f12837c76dc7bf/c5bb3/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png\"\n        srcset=\"/static/1785c5100f2860aff9f12837c76dc7bf/04472/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png 170w,\n/static/1785c5100f2860aff9f12837c76dc7bf/9f933/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png 340w,\n/static/1785c5100f2860aff9f12837c76dc7bf/c5bb3/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png 680w,\n/static/1785c5100f2860aff9f12837c76dc7bf/2a50c/cb281d3e229415c6abed2fad5a61b0a803ef6cdc.png 925w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>Building an heap requires to run <code class=\"language-text\">max_heapify</code> from the leaves up to the root. A conservative analysis would give us a time complexity of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n\\log n)\"></img> as we run <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> times <code class=\"language-text\">max_heapify</code> on trees that have depth <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img>. In reality, the leaves have a tree of depth 1, the nodes before the leaves (half) have trees of depth 2, the nodes even earlier (a fourth) have trees of depth 3 and so forth... As we move up to the root, there is longer but less tree to process. An accurate analysis, gives a time complexity of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\nO(n)\"></img>. We call the procedure <code class=\"language-text\">build_max_heap</code>. </li>\n</ul>\n<h3>The algorithm</h3>\n<p>The heapsort algorithm starts by using a <code class=\"language-text\">build_max_heap</code> to build a max-heap on the input array. Since the maximum element of the array is stored at the root of the heap, we can put it into its final position by exchanging it with <code class=\"language-text\">a[n]</code>. If we now discard node <code class=\"language-text\">n</code> from the heap (simply reducing the size of the heap) we observe that the children of the root might violate the heap property. We therefore heapify the heap again with a call to <code class=\"language-text\">max_heapify(a, 0, n-2)</code> , which leaves a max-heap in <code class=\"language-text\">a[0 : n-1]</code>. The heapsort algorithm then repeats, until when the size of the heap is 2. </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> Array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        max_heapify<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># heapify the remaining vector </span></code></pre></div>\n<h3>Analysis</h3>\n<ul>\n<li>We need to initially create the max-heap which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img></li>\n<li>For each value we extract, we need to max-heapify the heap. We extract <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\"></img> values</li>\n<li>The total complexity is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?n\\cdot O(\\log n) + O(n) = O(n\\log n)\"></img>.</li>\n</ul>\n<h3>Quicksort</h3>\n<p>The quicksort algorithm has a worst-case running time of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Theta(n^2)\"></img>. Despite this slow worst-case running time, quicksort is often the best practical choice for sorting because it is remarkably efficient on the average: its expected running time is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Theta(n\\log n)\"></img> and the constant factors hidden in the O-notation are quite small. </p>\n<p>Quicksort like merge sort, applies the divide and conquer paradigm:</p>\n<ul>\n<li>divide step: partition (rearrange) the array <code class=\"language-text\">a[p : r]</code> into two possibly empty subarrays <code class=\"language-text\">a[p : q-1]</code> and <code class=\"language-text\">a[q+1 : r]</code> such that each element of <code class=\"language-text\">a[p : q-1]</code> is less or equal to <code class=\"language-text\">a[q]</code> which is in turn less or equal to each element in <code class=\"language-text\">a[q+1 : r]</code> . Compute the index <code class=\"language-text\">q</code> as part of the partitioning procedure.</li>\n<li>conquer step: sort the two subarrays <code class=\"language-text\">a[p : q-1]</code> abd <code class=\"language-text\">a[q+1 : r]</code> by recursive calls to quicksort</li>\n<li>combine step: because the subarrays are already sorted, no work is needed to combine them: the entire array <code class=\"language-text\">a[p  : r]</code> is now sorted. </li>\n</ul>\n<h3>Partition routine</h3>\n<ul>\n<li>In the <code class=\"language-text\">partition</code> routine we take an array and find a intermediate point such that the values on the left of this intermediate point are less or equal to the intermediate point, the ones on the right, larger then the value at the intermediate point. </li>\n</ul>","frontmatter":{"title":"Sorting","description":"Some of the maaaany sorting algorithms."}}},"pageContext":{"slug":"/sorting/","previousPost":{"title":"Stacks and Queues","slug":"/stacks-and-queues/"},"nextPost":{"title":"Shortest Path","slug":"/shortest-path/"}}},"staticQueryHashes":["3868140423","4085307986"]}