{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/arrays/","result":{"data":{"markdownRemark":{"html":"<p>Contiguous are of memory consisting of equal-size elements indexed by contiguous integers. </p>\n<h3>Advantages</h3>\n<p>With array we have constant-time access to each element of the array</p>\n<ul>\n<li><code class=\"language-text\">a[i] = a[array_addr + elem_size x i]</code></li>\n<li><code class=\"language-text\">a[i, j] = a[array_addr + elem_size x (i * col_size) + j]</code>  → this assumes a row-major indexing → the array is placed in memory row after row</li>\n<li><code class=\"language-text\">a[i, j] = a[array_addr + elem_size x (j * row_size) + i]</code>  → this assumes a col-major indexing → the array is placed in memory column after column</li>\n</ul>\n<h3>Disadvantages</h3>\n<p>inserting and remove operations are not constant time if done at the beginning and middle of the array</p>\n<ul>\n<li>Add/remove at the end: <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img> as we just write the last index</li>\n<li>Add/remove in the middle or beginning is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> since we need to make place for the new element, and move all elements after it to the right (add) or left (remove) of one position. </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Add</strong></th>\n<th><strong>Remove</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Beginning</strong></td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td><strong>Middle</strong></td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td><strong>End</strong></td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h3>Dynamic Arrays</h3>\n<p>Allow to change their size at runtime. Under the hood a pointer to a dynamically allocated array is stored. If the size is not sufficient, reallocate new larger memory and copy the elements over and now use the pointer to the newly allocated array. These arrays are also called resizable arrays. In addition to the usual array, these array store:</p>\n<ul>\n<li>capacity: size of the dynamically allocated array</li>\n<li>size: number of elements currently stored in the array</li>\n<li>C++ implementation is <code class=\"language-text\">std::vector&lt;T&gt;</code></li>\n<li>Some space is wasted (capacity often larger then the actual size)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 342px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/cs-wiki/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABXUlEQVQ4y6VT266CQAzc//83gQcgETQEA3IRL6ACClrP9KRkuZwXzyZNS9kOnU5R9HP6vqf3+41w8N8edT6fCVaW5Qj0W1PH45GiKKL9fj985T9dqqqqyPM8Wq1WI7Cmaeh+v9Pj8WDDPbxr25YNudvtxveQv1wuvx2eTidar9cUBAFlWTZ8abPZkGEYFMcxFx4OB6rrmizLItM0yXVdvoNngG+3W3q9XqR0ekg+n08SoXCh67ohxpGcHMT67JVOsyiKocvr9UroHoYu0d10vkuxEnUERMRBHIYhq49xYFbTYl3dWYeS9H2facvAIQY8npEXuktg3OEU0LZtpoh1QmdQGiAAhNepT8EWO0Rhmqa8BpgnqENF8UJ9qUMwmAHq6orXTdReAsR79c3foQNNa0drA0qYW57n7LG8UB0jgMdyYwxTYfR4BohCLDjAHMdh1QG+2+0oSRI2jOUv2h83xpHvb7pUKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        title=\"1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        src=\"/cs-wiki/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        srcset=\"/cs-wiki/static/605f6abe3f2f45765fe2c754ce043eda/04472/1fd15703bc9f337362fb54203397077b764bfe67.png 170w,\n/cs-wiki/static/605f6abe3f2f45765fe2c754ce043eda/9f933/1fd15703bc9f337362fb54203397077b764bfe67.png 340w,\n/cs-wiki/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png 342w\"\n        sizes=\"(max-width: 342px) 100vw, 342px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>When we want to push back c the original capacity (2) is changed to 4 as we allocated a new array dynamically and we copy the old one over. As we do that, the old array is disposed. </em></p>\n<ul>\n<li>Note that inserting is now <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> since we might need to allocate a new array and copy all the old arrays over. Here is an example of where we can use amortized cost. In this case many <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img> operations are followed by some rare <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> operations.</li>\n</ul>\n<h2>Aggregate Method</h2>\n<p>Here we compute an average cost where the single cost is the sum of the best case cost and the sporadic big cost incurred because of increasing the capacity. We assume that the policy here is to multiply by a factor of 2 the vector each time we hit the maximum capacity. That means that we have an exponential growth. The cost of an insert operation will be</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?c_i = 1+ \\begin{cases}\ni-1 &amp; \\text{ if }\\ i-1=2^k \\text{ for some }k \\\\\n0 &amp; \\text{otherwise}\n\\end{cases}\"></div>\n<p>Then we hit a full resizing when the size is 2, 4, 8, 16, 64 ... . This is equivalent to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\log_2 (n-1)\"></img>. Then the overhead will be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Sigma_{j=1}^{\\lfloor \\log_2 (n-1) \\rfloor} 2^j\"></img> . What is the cost of this summation? We can use the sum formula <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Sigma_{k=0}^{n-1} a^k = (1- a^n) / (1 - a) \\text{ if }a\\neq 1\"></img>. That means that the sum is equivalent to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?2n - 2\"></img> and the amortized cost will be:</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\hat{c}_i = \\frac{\\Sigma_{i=1}^{n} c_i }{n} = \\frac{n + \\Sigma_{j=1}^{\\lfloor \\lg(n-1)\\rfloor}2^j}{n} = \\frac{n + 2n -2}{n} = O(1)\"></div>\n<p>The worst case cost is still <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n)\"></img> but the amortized cost is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(1)\"></img>. </p>\n<h3>Bankers Method / Amortizing Loan</h3>\n<p>This is the same method as the one introduced in the binary counter. What we do is charge extra for each cheap operation so to pay back expensive operations when they occur. In this case, we assume that for each <code class=\"language-text\">push_back</code> that we do we pay 3 (instead of 1, which means still constant time):</p>\n<ul>\n<li>A cost of 1 for the usual insertion</li>\n<li>We prepay for this new element a cost of 1 when this will be moved in a future insertion operation.</li>\n<li>We prepay a cost of 1 for moving in the future an element which is located at index capacity/2. </li>\n</ul>\n<h3>Physicist Method / Potential Method</h3>\n<p>Using the potential function we can achieve the same result. In this case we define the potential function to be <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Phi(\\text{v}) = 2 * \\text{v.size} - \\text{v.capacity}\"></img>. As we grow in size, the potential increases (we get closer to the condition where all the array needs to be resized). As the size is equal to the capacity,  2 * size - capacity  = capacity which is the number of elements that we have to move again because of reallocation. Our potential function need to be non negative (true as size <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\geq\"></img> capacity/2) and start at 0 (empty array —> 2*0 + 0 = 0).  </p>\n<ul>\n<li>Initially v.capacity = 0 and v.size() = 0</li>\n<li>Amortized cost without resizing (capacity does not increase):<img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\hat{c}_i = c_i + \\Phi(\\text{v}_i) - \\Phi(\\text{v}_{i-1}) = 1 + 2 size_{i} - cap_i -2size_{i-1} + cap_{i-1} = 1 + 2 * (size_i - size_{i-1}) = 1 + 2 = 3\"></img></li>\n<li>Amortized cost with resizing (<img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?size_{i-1} = cap_{i-1} = k\"></img>)\n<img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\hat{c}_i = c_i + \\Phi(\\text{v}_i) - \\Phi(\\text{v}_{i-1}) = size_{i} + 2 size_{i} - cap_i -2size_{i-1} + cap_{i-1} = k + 1 +  2(k+1) - 2k -2k + k = 1 + 2 = 3\"></img></li>\n</ul>\n<h3>Can we use other resizing policies?</h3>\n<p>What if added 10 to the capacity every time we hit the limits? Would the amortized cost be the same? We can use the aggregate method to see that</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\hat{c}_i = \\frac{n + \\Sigma_{j=1}^{(n - 1) /10}10j}{n} = \\frac{n + 10 (n-1)(n)/100}{n} = \\frac{n + (n-1)n/10}{n} = O(n)\"></div>\n<h3>Jagged Arrays</h3>\n<p>An array of arrays. It allows to store a different number of columns for each row. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> ml <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nml<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nml<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nml<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nml<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"title":"Arrays","description":"Arrays, the most widely used and probably simple data structure"}}},"pageContext":{"slug":"/arrays/","previousPost":{"title":"Disjoint Sets","slug":"/disjoint-sets/"},"nextPost":{"title":"Bits Manipulation","slug":"/bits-manipulation/"}}},"staticQueryHashes":["3868140423","4085307986"]}