{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/arrays/","result":{"data":{"markdownRemark":{"html":"<p>Contiguous are of memory consisting of equal-size elements indexed by contiguous integers. </p>\n<h3>Advantages</h3>\n<p>With array we have constant-time access to each element of the array</p>\n<ul>\n<li><code class=\"language-text\">a[i] = a[array_addr + elem_size x i]</code></li>\n<li><code class=\"language-text\">a[i, j] = a[array_addr + elem_size x (i * col_size) + j]</code>  → this assumes a row-major indexing → the array is placed in memory row after row</li>\n<li><code class=\"language-text\">a[i, j] = a[array_addr + elem_size x (j * row_size) + i]</code>  → this assumes a col-major indexing → the array is placed in memory column after column</li>\n</ul>\n<h3>Disadvantages</h3>\n<p>inserting and remove operations are not constant time if done at the beginning and middle of the array</p>\n<ul>\n<li><img src=\"https://render.githubusercontent.com/render/math?math=O(1)\"></img> as we just write the last index</li>\n<li><img src=\"https://render.githubusercontent.com/render/math?math=O(n)\"></img> since we need to make place for the new element, and move all elements after it to the right (add) or left (remove) of one position. </li>\n</ul>\n<h3>Dynamic Arrays</h3>\n<p>Allow to change their size at runtime. Under the hood a pointer to a dynamically allocated array is stored. If the size is not sufficient, reallocate new larger memory and copy the elements over and now use the pointer to the newly allocated array. These arrays are also called resizable arrays. In addition to the usual array, these array store:</p>\n<ul>\n<li>capacity: size of the dynamically allocated array</li>\n<li>size: number of elements currently stored in the array</li>\n<li>C++ implementation is <code class=\"language-text\">std::vector&lt;T&gt;</code></li>\n<li>Some space is wasted (capacity often larger then the actual size)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 342px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABXUlEQVQ4y6VT266CQAzc//83gQcgETQEA3IRL6ACClrP9KRkuZwXzyZNS9kOnU5R9HP6vqf3+41w8N8edT6fCVaW5Qj0W1PH45GiKKL9fj985T9dqqqqyPM8Wq1WI7Cmaeh+v9Pj8WDDPbxr25YNudvtxveQv1wuvx2eTidar9cUBAFlWTZ8abPZkGEYFMcxFx4OB6rrmizLItM0yXVdvoNngG+3W3q9XqR0ekg+n08SoXCh67ohxpGcHMT67JVOsyiKocvr9UroHoYu0d10vkuxEnUERMRBHIYhq49xYFbTYl3dWYeS9H2facvAIQY8npEXuktg3OEU0LZtpoh1QmdQGiAAhNepT8EWO0Rhmqa8BpgnqENF8UJ9qUMwmAHq6orXTdReAsR79c3foQNNa0drA0qYW57n7LG8UB0jgMdyYwxTYfR4BohCLDjAHMdh1QG+2+0oSRI2jOUv2h83xpHvb7pUKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        title=\"1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        src=\"/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png\"\n        srcset=\"/static/605f6abe3f2f45765fe2c754ce043eda/04472/1fd15703bc9f337362fb54203397077b764bfe67.png 170w,\n/static/605f6abe3f2f45765fe2c754ce043eda/9f933/1fd15703bc9f337362fb54203397077b764bfe67.png 340w,\n/static/605f6abe3f2f45765fe2c754ce043eda/e2c15/1fd15703bc9f337362fb54203397077b764bfe67.png 342w\"\n        sizes=\"(max-width: 342px) 100vw, 342px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n**</p>\n<ul>\n<li><img src=\"https://render.githubusercontent.com/render/math?math=O(n)\"></img> operations.</li>\n</ul>\n<p><p style=\"color: red\">Error: VideoService could not be found</p></p>\n<h2>Aggregate Method</h2>\n<p>Here we compute an average cost where the single cost is the sum of the best case cost and the sporadic big cost incurred because of increasing the capacity. We assume that the policy here is to multiply by a factor of 2 the vector each time we hit the maximum capacity. That means that we have an exponential growth. The cost of an insert operation will be</p>\n<p><img src=\"https://render.githubusercontent.com/render/math?math=2n - 2\"></img> and the amortized cost will be:</p>\n<p><img src=\"https://render.githubusercontent.com/render/math?math=O(1)\"></img>. </p>\n<h3>Bankers Method / Amortizing Loan</h3>\n<p>This is the same method as the one introduced in the binary counter. What we do is charge extra for each cheap operation so to pay back expensive operations when they occur. In this case, we assume that for each <code class=\"language-text\">push_back</code> that we do we pay 3 (instead of 1, which means still constant time):</p>\n<ul>\n<li>A cost of 1 for the usual insertion</li>\n<li>We prepay for this new element a cost of 1 when this will be moved in a future insertion operation.</li>\n<li>We prepay a cost of 1 for moving in the future an element which is located at index capacity/2. </li>\n</ul>\n<h3>Physicist Method / Potential Method</h3>\n<p><img src=\"https://render.githubusercontent.com/render/math?math=\\geq\"></img> capacity/2) and start at 0 (empty array —> 2*0 + 0 = 0).  </p>\n<ul>\n<li>Initially v.capacity = 0 and v.size() = 0</li>\n<li><img src=\"https://render.githubusercontent.com/render/math?math=\\hat{c}_i = c_i + \\Phi(\\text{v}_i) - \\Phi(\\text{v}_{i-1}) = 1 + 2 size_{i} - cap_i -2size_{i-1} + cap_{i-1} = 1 + 2 * (size_i - size_{i-1}) = 1 + 2 = 3\"></img></li>\n<li><img src=\"https://render.githubusercontent.com/render/math?math=\\hat{c}_i = c_i + \\Phi(\\text{v}_i) - \\Phi(\\text{v}_{i-1}) = size_{i} + 2 size_{i} - cap_i -2size_{i-1} + cap_{i-1} = k + 1 +  2(k+1) - 2k -2k + k = 1 + 2 = 3\"></img></li>\n</ul>\n<h3>Can we use other resizing policies?</h3>\n<p>What if added 10 to the capacity every time we hit the limits? Would the amortized cost be the same? We can use the aggregate method to see that</p>\n<h3>Jagged Arrays</h3>\n<p>An array of arrays. It allows to store a different number of columns for each row. </p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int [] [] ml = new int[4][]\nml[0] = new int[6];\nml[1] = new int[4];\nml[2] = new int[7];\nml[3] = new int[2];</code></pre></div>","frontmatter":{"title":"Arrays","description":"Array","image":{"childImageSharp":{"resize":{"src":"/static/d823f79d4c7281a49a3915c97ec9cfb4/c7a62/0ffe9139be5df720821282dedf3f69d236bef3ce.jpg","height":630,"width":1200}}}}}},"pageContext":{"slug":"/arrays/","previousPost":{"title":"Introduction and Big O Notation","slug":"/introduction-and-big-o-notation/"},"nextPost":null}},"staticQueryHashes":["3868140423","4085307986"]}