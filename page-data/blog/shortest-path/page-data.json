{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/shortest-path/","result":{"data":{"markdownRemark":{"html":"<h2>Shortest Path Algorithms</h2>\n<p>The problem is to find a path from start to end node with the smallest weight.</p>\n<ul>\n<li>Dijkstra's: runs on graph with positive edges and can run <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n\\log n + m)\"></img>.</li>\n<li>Bellman-Ford: works for positive and negative edges and as order <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(me)\"></img>.</li>\n</ul>\n<p>We introduce the path distance as <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta\"></img> between nodes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v\"></img>. This is given by the smallest of such paths <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p\"></img> that connect <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v\"></img>. If not connected, we set its value to infinity. </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\delta(u, v) = \n\\begin{cases}\n\\min \\{ w(p): u \\rightarrow v\\} \\ &amp; \\exists \\text{   any such path} \\\\\n\\infty&amp; \\text{ otherwise} \n\\end{cases}\"></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 490px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/22b85f98750f04f1631eae058286356d/41d3c/3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACHElEQVQ4y31UaY+bMBDN//9RldovlapWqqpdRVW2TcmBCdgcBmyDj9cxCSlsojqxBuw53sy8YYPbCiHc5bzpbb5G6/X9GUudKBf2G2CpF1bSkBDdAN4a7KsGudSo1YhxaXMLMK/NElVc1l7VS3LCzyV0XsHkAkE0sLxGf6lQpAKZNNCjvaF9gnA+EELgUCuwtIIbFIw3KGWHi6NgdN8HA2iDb0mNHeNk6NcpT+hwi0I/TZJLhUqP2GmLV0LyvbTomhpvnaOt8bn0aGQDpvwKzCplTP8RjKJ+PCp8qRycDxi8x0si8Oli0NqrUaY9tvWA3PipisuSbeaHeNVRwQtWYk8wv5YOJ0up8hRHVuGDuHbU0eZDQPQV5VOEg1I4Ugd3TExRK2eQDR6tseDHApb0T1qhsYqcADnVNq5EabSki/e0GY1GTvQ4dCPSXMK2/dSE9CRQNVf+iRjAepSEygc3naVUZ+PHtcMlXAuHfSvxM6mw5RonVsPf7n6rgB9NuL+LMTrEYhgeeBilg6QmbEuDg5DIGoMk53gl58eyQSItyrLCy0XiV9EiIXqpK7MfEd6bQw6LVk9dzGoNTY7eshqMiM6oJC0FYrzDgej0h8qhrX+s4bLtfd+j4hxnSulA3R5iekVB9Pk3brFqnChUU60HrR8dvp+WeUojRWIzCvLKqONnIvrFRNp4WB+e2m3+/7W5jz86ood0enW21JvlX+G8k0RyZhJ9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png\"\n        title=\"3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png\"\n        src=\"/static/22b85f98750f04f1631eae058286356d/41d3c/3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png\"\n        srcset=\"/static/22b85f98750f04f1631eae058286356d/04472/3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png 170w,\n/static/22b85f98750f04f1631eae058286356d/9f933/3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png 340w,\n/static/22b85f98750f04f1631eae058286356d/41d3c/3111ecb45b302cb13e62800c3cb71a4a62bf0e38.png 490w\"\n        sizes=\"(max-width: 490px) 100vw, 490px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The number inside each node is the current weight associated with that node, the length of the path that reaches that node from start. At the beginning we can think that they are all infinity. As we move from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?S\"></img> down to the other nodes, we find a way to get there with a smaller weight, and we update the corresponding value. We call <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v]\"></img> as the current value in the vertex and we have that</p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\begin{align*}\nd[v] &amp;= \\text{ value inside circle}\\\\\n&amp;= \\begin{cases}\n0 &amp; \\text{ if }v = s \\\\\n\\infty &amp; \\text{ otherwise}\n\\end{cases}\\\\\n&amp;= \\delta(s, v) \\Leftarrow \\text{  at end} \\\\\nd[v] &amp;\\geq \\delta(s, v) \\text{ at all times} \n\\end{align*} \"></div>\n<p><img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v]\"></img> decreases as we find better path to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v\"></img>. <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Pi[v]\"></img> is the predecessor on the best path to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Pi[s] = \\text{nil}\"></img>. These are the data structures we have to iterate on:</p>\n<ul>\n<li>the predecessor (parents) array <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Pi[v]\"></img></li>\n<li>the current distance to node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v]\"></img></li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6d5a2dd442bc905a51e25648c014b5eb/9f933/49d7870746edd62894c6266db249b042db81cc80.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABz0lEQVQ4y5VUW3LiMBD0/S+UA+QCW8lHeBjIAgY7xhuDLeut3pFUDrYJeahqShpZ09M9M5DgB8s5N9rv3fmV/BZMdgxKyrugyXcgQ/Pr778GVdcD3mE4DsQIIEbGbc8tOgsU0oEbCzt43+Mk0+DhWStiojQa2+KVC6StQ06guw6YsRrC8Zu4pI+/aIdKRafRbdjL9xrLY4WUG5y1wUkAD7kO32aNxaK1YMZBax1EBIZwlPGtQkaZPaCXteMN/tQam87hbIA1i4kKKfAmbaxl55lalOSn+/wq2Reo4RK5sDgSgzLUBzhwFwIqCnhpFT0nRuwCYR0U2fPF4kRvC4pjygxrGCUTcywZ+2DQd7EmOU9tieezpaQgEGDDBFojQmJuxqMTGPZO5xgeKx1qI+21Of44p5qlzFJzQrWIgP10zEZd5tIQQxfAdvwa4GX6+47YHJkazWCvcNDlK2B+OCCjevk5q1Vk4mIkdRnYXgS22/3N0E8k3067dPjVGv30esdQ8TkNr58pSyalIpPBV0qFXap4J4QIFuZvyvCjIW2D2csCr+s1qlOFU1nReYPVcoVsu0ORF8Gfz+bIsj3S+QKr1YZAzdeSp/I/+6MYfpsy/A97TOedh71v1wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"49d7870746edd62894c6266db249b042db81cc80.png\"\n        title=\"49d7870746edd62894c6266db249b042db81cc80.png\"\n        src=\"/static/6d5a2dd442bc905a51e25648c014b5eb/9f933/49d7870746edd62894c6266db249b042db81cc80.png\"\n        srcset=\"/static/6d5a2dd442bc905a51e25648c014b5eb/04472/49d7870746edd62894c6266db249b042db81cc80.png 170w,\n/static/6d5a2dd442bc905a51e25648c014b5eb/9f933/49d7870746edd62894c6266db249b042db81cc80.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We can try to get rid of the negative weights by offsetting all the weights, such that they all become positive. In general a desirable condition for the algorithm is that it terminates. If we have cycles with negative cycles, the distances <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d\"></img> are not bound by zero, as we keep going through the cycle and reducing the weight (e.g B → D → C → B → ...). It is not like all the paths are undefined in the previous graph. E.g the path from S → A is well defined and has weight 2 (there is no way of going through the negative cycle to reach A)</p>\n<p>This kind of problem is what Bellman-Ford does: for edges that touch a cycle, it returns -infinity (indeterminate path) and for all other determinate nodes, it finds the finite distance admissible path (like from S to A in the previous example). </p>\n<h3>Relaxation</h3>\n<p>The general structure of the shortest path algorithm for non negative cycles  is as follow:</p>\n<p>The idea is that at some point, we are not able to relax edges anymore, none of them. In fact if one edge can be relaxed, maybe others can be relaxed now. So we really need to wait for all the edges to not improve. This is a brute force algorithm, especially if for each node we check each edge. </p>\n<p>Lemma: the relaxation operation maintains the invariant that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v] \\geq \\delta(s, v)\"></img> for all <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v \\in V\"></img></p>\n<p>Proof: by induction on the number of steps by induction. We start with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[u] \\geq \\delta(s, u)\"></img>. By the triangle inequality <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta(s, v) \\leq \\delta(s, u) + \\delta(u, v)\"></img> (the shortest way is less or equal than a way to another intermediate node). By induction <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta(s, u) \\leq d[u]\"></img> and by construction <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta(u,v) \\leq w(u,v)\"></img>.  It follows that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta(s, v) \\leq d[u] + w(u,v) = d[v]\"></img>. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 663px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ebbb772db151098618f83a13ddf582b7/0786c/86dcba8b48bcf8604a549042cef5e90803aad528.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 106.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsSAAALEgHS3X78AAACmElEQVQ4y2VUV5bbMAz0/Q+Y/OWt15LYVCj2rgzlugmfTJOgBhgMQF2MMdM0kWkKIRw/R2vt8ddarfX4b1yM1tMwcs610qsQ67ysyyI4l9uGGWOZF6ON2lUp5V9wjBEHVut935mYd6WtMXpX+7ZppWCNPiBse0Zun+D7XzoOh6ceph7S53gcph26Hr40h0Vue24mFmzho7QXuGHTWKh/TBKxXU36Uunm0uDL6PPv1ZNQrzbPqf1a3OgrHhabTC3UZ2Ttok9ZhxRydqmElF3MNp7bmEMu2sdSm8W+HsonrHvkU8p2nCnFU3DMtdRaincO890YnIPsULf2Ejx4X0oshrscupLw4lZfS/usFhTtouTcCWr9qN8DnKrbQvZFzxYCOxlzzM/q9voGH14uoP8PMBgC7NdoQ5iCNMJ5E3BeckZhAc6I2VpK6QTrz265gGpyOZrc8zwaiLT69o2cc+pE7jPAn61yedHoi9caXfExupen4Xha7u1pOOVoMsHQibPgYuaCU7ZtUq5y5pxSKni3o0+3bVsx5vUBhoDjMCzLwij9/rqu64budA5lMhaPsUopa/t+lxJrXCRn7as9GyppNUqIn8FLEDamGG0LBjlXSFVygQ3KpRS988H7N21KCCV0HEZcr+vXdbiN0ziycWGDpITdrt+ccVimYUA6d5oPMLJllIESDnCrkREyR6pCCEL6PSfDBBUYluOENwXkWOU78ngbOGO8C7Zs66bkjpsI9yDCTo/wu4h5XVZyWoZheAqmFJ0IjsG831+5w4U8VYUj6DyfOgOptq1H7ozImzYi375vAKMewJwB4YySkQCGFDphQmGfhWCUg+MbDEr4elhroXgvkemaQ1IM9BOExxpfON0/Mnin1+8O/gu2Ebf+vK3hbgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"86dcba8b48bcf8604a549042cef5e90803aad528.png\"\n        title=\"86dcba8b48bcf8604a549042cef5e90803aad528.png\"\n        src=\"/static/ebbb772db151098618f83a13ddf582b7/0786c/86dcba8b48bcf8604a549042cef5e90803aad528.png\"\n        srcset=\"/static/ebbb772db151098618f83a13ddf582b7/04472/86dcba8b48bcf8604a549042cef5e90803aad528.png 170w,\n/static/ebbb772db151098618f83a13ddf582b7/9f933/86dcba8b48bcf8604a549042cef5e90803aad528.png 340w,\n/static/ebbb772db151098618f83a13ddf582b7/0786c/86dcba8b48bcf8604a549042cef5e90803aad528.png 663w\"\n        sizes=\"(max-width: 663px) 100vw, 663px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The number of the time we relax the edge can be of the order of the range of the weights. So for the last edge of weight in the previous pathological example, we might end end up reducing this edge 2^n/2 times which make this algorithm exponentially complex. </p>\n<h3>Optimality principle</h3>\n<p>(Optimal Substructure) — sub-paths of a shortest path are shortest paths. </p>\n<h2>Shortest Paths on DAGs</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">shortest_dags</span><span class=\"token punctuation\">(</span>Graph g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 1) topologically sort graph G --> path from u to v implies that u is before v in the ordering</span>\n  <span class=\"token comment\">// 2) traverse vertices from left to right --> relax edges whenever possible </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 653px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b0bcf1bd99b04efbfea67e2572ff9866/e7dce/6f83852d36e6d042e5a652277a46f0fee6ccced9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABW0lEQVQoz22R627CMAyFef/n24/dtGnaDWjTpLk1cdKcOaGFArNk2Y7dDx+zQ7VSllDjKV+jchNcTOd+nOtbWLqn+bJ+wra7gIA8F8iJIBlyNBN+9ITOR+wd4XmvznXnCS+dxudgkBfwyrgA2evTtwn4sAlvyuPHJTzsNb4s4Z3r2nsUHr/a43VweDqMJ2C5AZ7XXqAmEHRI8CwvpAxBgOB6YKmeMkIusKkgzdtT3UheHavfWGC3aYZhoOd2XkZKuYbuymbd1WKMGMcR0zTBGANrLRxHYyyUGmG4R0T/A9ciTAHEoApz1jWQd77lFVhhjmNiEFHCdoU7yXVI9AKjUhDiFAcxQA7sUqI7dlBStfeUInJOvD3f03vO8/2GRmv0fd8GNOdtK96w5kYbhguWKiGFhTjwCYzjk2j+Ecmq6B4YQ2gAanJoGSotrydo0h1LHvkPUawoXd98K/kPxL0OT/e1NrIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6f83852d36e6d042e5a652277a46f0fee6ccced9.png\"\n        title=\"6f83852d36e6d042e5a652277a46f0fee6ccced9.png\"\n        src=\"/static/b0bcf1bd99b04efbfea67e2572ff9866/e7dce/6f83852d36e6d042e5a652277a46f0fee6ccced9.png\"\n        srcset=\"/static/b0bcf1bd99b04efbfea67e2572ff9866/04472/6f83852d36e6d042e5a652277a46f0fee6ccced9.png 170w,\n/static/b0bcf1bd99b04efbfea67e2572ff9866/9f933/6f83852d36e6d042e5a652277a46f0fee6ccced9.png 340w,\n/static/b0bcf1bd99b04efbfea67e2572ff9866/e7dce/6f83852d36e6d042e5a652277a46f0fee6ccced9.png 653w\"\n        sizes=\"(max-width: 653px) 100vw, 653px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>In the previous example <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> is the starting vertex. The DAG is already shown in his topological order. All vertices at the left of s cannot be reached since the graph is already topologically ordered. In this case we know that r will always stay at infinity, also during the relaxation procedure. In figure 1, everything start at infinity as starting point of the relaxation procedure. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 495px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/42e1f3ec7924a375f859844baf6c4839/a4d88/4fceaad27787fb2347e827ae3ac9afda8331303d.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACiElEQVQ4y5VU23KbMBTk/7+rL31KO5nJNHEax3awzR2BAIEu25UwNnb7Us0ISUfSueyuiJxz8M1//Tx0LM1hGke/EfrtJGCm6c4erJxHuDiCu7mBs7Bcttrhq6hRj+YaYOSGtEDa9BCTnR1Ze3UczWuLTCqU/Yhz1eDcKmzFgFh0SAeNjPYfhxK/jiU+aU95NqbDVA74+ZnhPWugjA0hI+/Zx9+LHjv2V2mwSQUOvPRSK2ySGsd+wqYZsc0E9rQ/5x12RYuY9qdTjddEQOi5wmiu1GFggIywSJZRs7dcn+oB77wcE0bDg6eqRcfzX2WPjFX4dmaghOcW6CLvzK3wK0QbMBvsjZxytDgxYs7ya9n7G/AFFrTLC7wLmdHiTGuDicw5a2aQL4HsZb83Di230rZHqQyqyUFZdz33F8tpkuD4FSPPCxTsds06bhd9QrOfW9ClY50h1ipzM2OEEnlZXxlcGpND0/X39uB0JRvFkg1D21Fh4LxUGkWncCL4+TAhaQbkLLcgjoIYH7n2Z04VIaD9mqHPifDgo5TY112QxAtl8F512JC9A6V07iZ8pw6fdhl+C4U37u0qiQ/ufdsmeD6Lq/ijReEFgT4OBi0XMbNqGGVbUrhxjYRyUs5LpAtyeksltrmc9UutfqQNpoUUNz/i4H30l+oWDcFreFoyqiZOh8EhZ8BUyJBJ57Nx/hkS42FRxYMOFwz8o3d3DCMw7mVS8m5JnfYeY41gu3GyYnnhd/GzlsLy4/CjJmn+hyC1DfO1nFYZ4s7wv+3xTvS40TZ89BS4EGSuqoLIq7JEnuWc5xyLME/PCaqqvqvonw6NMVCDCqMhVlprjjo8Sz/33f909TTbHqv7A2vKfs9dv0L+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4fceaad27787fb2347e827ae3ac9afda8331303d.png\"\n        title=\"4fceaad27787fb2347e827ae3ac9afda8331303d.png\"\n        src=\"/static/42e1f3ec7924a375f859844baf6c4839/a4d88/4fceaad27787fb2347e827ae3ac9afda8331303d.png\"\n        srcset=\"/static/42e1f3ec7924a375f859844baf6c4839/04472/4fceaad27787fb2347e827ae3ac9afda8331303d.png 170w,\n/static/42e1f3ec7924a375f859844baf6c4839/9f933/4fceaad27787fb2347e827ae3ac9afda8331303d.png 340w,\n/static/42e1f3ec7924a375f859844baf6c4839/a4d88/4fceaad27787fb2347e827ae3ac9afda8331303d.png 495w\"\n        sizes=\"(max-width: 495px) 100vw, 495px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>During processing we start at the start node and we traverse the graph to the right, and we process each vertex and all its edges at  a time. As we are processing each edge in the cycle in the worst case and going through all nodes, even if they have no edges, the complexity is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?O(n + m)\"></img>.</p>\n<h2>Dijkstra’s Algorithm</h2>\n<p>Dijkstra’s algorithm solves the single-source shortest path problem on a weighted, directed graph for the case in which all edge weights are nonnegative. It maintains a set S of vertices whose final shortest-path weight from the source s have already been determined. The algorithm repeatedly select the vertex <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u \\in V - S\"></img> with the minimum shortest-path estimate, add <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u \"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?S\"></img>, and relaxes all edges leaving <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img>. In the following implementation, we use a min-priority queue Q of vertices, keyed by their <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d\"></img> values. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// uses priority queue Q where values are the d values</span>\n<span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>Graph G<span class=\"token punctuation\">,</span> Weights W<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n  Set S<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// set that contains the set of vertices we know the shortest path to</span>\n  PriorityQueue Q<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token comment\">// Q ← V[G]   insert all vertices into Q → vertices that need to be processed. Ordered according to d and d[s] = 0</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    u <span class=\"token operator\">=</span> Q<span class=\"token punctuation\">.</span><span class=\"token function\">extract_min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// claiming that the min is something we obtained the shortest path to already </span>\n    S<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          \n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>vertex <span class=\"token operator\">:</span> Adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token function\">relax</span><span class=\"token punctuation\">(</span>Q<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// this is ian implicit descreas_key operation</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note that the relax operation operates on the queue and also maintains the parents array which is not explicitly mentioned in the previous pseudo-code block. </p>\n<p>Intuitive proof</p>\n<p>Intuitively we know that S starts with the start vertex for which the shortest path is 0 (itself). We progressively expand the boundaries of S, adding new vertices. The min of the queue points to a node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img> that we are going to insert into S. This must be the shortest distance to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img>. If it wasn't so, there can be another path that reaches <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img> that start in S and ends in <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img>. This path must have lower distance then the one stored at the top of the priority queue. But if that would have been the case, it means, that there is some vertex just outside the boundary of S and belonging to this alternative path, lets call it <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img>, that has shortest path <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\delta(s, x)\"></img> that has not been added to the queue. But if that is the case, we would have already relaxed that node and have <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> in the queue. This is in contradiction with the fact that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img> was the minimum stored path in the queue.  </p>\n<p>Note that we rely on the fact that there aren't negative edges. If there are negative edges, we could have a way to reach out of the boundaries of S that is not visible now but that goes through some negative edge back to the node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?u\"></img>. </p>\n<p>Example</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 562px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8319a167fd0dd3d4a3bde64cc157cc73/6e88f/66783ba34103a3fb91139f0c8b01f9bc85641867.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACmklEQVQ4y4VVi3KbMBDM//9a32mnzTTxC4wxGJBAQgiE2N5hOwHCpJqRhdFpb+9uTzxgMYZhGFfvPfq+n+31vccwsRvwfjxMge6TR9u20HEKnwlYa1B4A5kkcGkOdO4KNrFfBZwC8wlDAMnhgKYUCJ1EdNpDvOzhhJydWQVcGiS9xkYeEWZHlJ0Z3z3lMf7EG5SNnjv/iKEsBFoKK7vEEM5A+AZZp+i5xtZm0EOHtKvgB7/K8h2gMw3UPkAbnqFbDdEbnNsSoS2Q0Fr3LeJWov8f4GyztijLHCdicjYFTgTgCKAZHApbQfXNWJSPQ7793A0sPPZFjGO4g5IFsr6GUAJxdIArqzcCa4AzyfDqb1q8FLCUT0d5jYntKY2gI5IOSQl3HS5YPiwpT8OoNVVT6RmLOr1gIB3iIx1yV6hKoWmat5BJ2LKqUNM7fq+1gq4NHHUP27A9n1s2xBWQWqqiw1VZwrmr91aWkLsAxhiYEVCPz9NOWmvbV4aiKJBSZyilrn1baeTPW4j4DElTSDkyZSB2yqu1FqauZ5G9AnK+JLVUdaugJwNJ4CY6w56SEcBTuGzTElCwP2D7shnnhiZjzAA53DzLUMprnzKLmrxrKkrDTJIMHYFL2re2we+fv/D102f8+PINj98f54BMtyMGza0AA20yw5a6pqPJheioIF7VI1O+1o5BODIL6fIIg+P7kLkogvR2SVM4kgX701SUNiDtkRPOl10UYk1yr4BFniM5J2PYp+iEhphVFB474uoqWru2gxBiLATbJlSsYxCM9jOG/IdzxmEzO2Zzv7F53p/ZjlPSk+1hu8Pz01/sNluau7ccrl2Sy45Zs2EC7PzucBbyVO3Tb0ocRWOIrFHObZHTJXG5kGzWRc3jH3dzZseWsapRAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"66783ba34103a3fb91139f0c8b01f9bc85641867.png\"\n        title=\"66783ba34103a3fb91139f0c8b01f9bc85641867.png\"\n        src=\"/static/8319a167fd0dd3d4a3bde64cc157cc73/6e88f/66783ba34103a3fb91139f0c8b01f9bc85641867.png\"\n        srcset=\"/static/8319a167fd0dd3d4a3bde64cc157cc73/04472/66783ba34103a3fb91139f0c8b01f9bc85641867.png 170w,\n/static/8319a167fd0dd3d4a3bde64cc157cc73/9f933/66783ba34103a3fb91139f0c8b01f9bc85641867.png 340w,\n/static/8319a167fd0dd3d4a3bde64cc157cc73/6e88f/66783ba34103a3fb91139f0c8b01f9bc85641867.png 562w\"\n        sizes=\"(max-width: 562px) 100vw, 562px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Complexity</p>\n<ul>\n<li>Operations in Dijkstra’s Algorithms:</li>\n<li>Array</li>\n<li>Binary min-heap</li>\n<li>Fibonacci heap:</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 651px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/83bccc0a3c3ece220711d9b2773d4266/1ac66/60be7e743c93dda79c13b4516040fa4775e01ae8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.58823529411764%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAABOklEQVQoz32Rx5LDMAxD9f9f6fG4l7ise8u+JRIlOWx44EAUAYKSu3+N4ziWZZnnmfxjsa7rtm26dV+Y53lCI1/XpQqAI0JI/JHRBvlr8L7vwn3fD8PwbkFtZCxQceM4YmOaJjhgyDRxBMuwPPsGMopk+A6kfbho25YmupkpTJErWUAXzC1XUJqmcWhQZRP52Sw89iuAIaiNrO2cv9PM1UJuBd5f5HqGsBPCVVEUN4u6rquqImOMIib/+44Hma3SNM3zPI7jLMvASZLAjKIIFRxKF7nWQuu8Jpdl2VgAmEymGzla+RU9m388Ki8yVfpqi9KC4WSMIMGLIIGiH/4xGTJuKwtJcBRZtmnoug5yb/GYrNX5T5raZ0iebtYmi0xQh8m/fDwY1SAIeCRGKSvCMESU36KBsfKFnMi/0HYnZ2rkYDEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"60be7e743c93dda79c13b4516040fa4775e01ae8.png\"\n        title=\"60be7e743c93dda79c13b4516040fa4775e01ae8.png\"\n        src=\"/static/83bccc0a3c3ece220711d9b2773d4266/1ac66/60be7e743c93dda79c13b4516040fa4775e01ae8.png\"\n        srcset=\"/static/83bccc0a3c3ece220711d9b2773d4266/04472/60be7e743c93dda79c13b4516040fa4775e01ae8.png 170w,\n/static/83bccc0a3c3ece220711d9b2773d4266/9f933/60be7e743c93dda79c13b4516040fa4775e01ae8.png 340w,\n/static/83bccc0a3c3ece220711d9b2773d4266/1ac66/60be7e743c93dda79c13b4516040fa4775e01ae8.png 651w\"\n        sizes=\"(max-width: 651px) 100vw, 651px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>Why Dijkstra would be incorrect with negative edges: it wouldn see that a found short path can be further reduced with a negative edge that becomes visible further in the future. </em></p>\n<h2>Bellman-Ford Algorithm</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">bellman_ford</span><span class=\"token punctuation\">(</span>Graph g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>size_t i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>          <span class=\"token comment\">// we do not explicitly use a starting vertex</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>edge <span class=\"token operator\">:</span> g<span class=\"token punctuation\">.</span>edges<span class=\"token punctuation\">)</span> <span class=\"token function\">relax</span><span class=\"token punctuation\">(</span>edge<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>edge <span class=\"token operator\">:</span> g<span class=\"token punctuation\">.</span>edges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> d<span class=\"token punctuation\">[</span>edge<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> d<span class=\"token punctuation\">[</span>edge<span class=\"token punctuation\">.</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> edge<span class=\"token punctuation\">.</span>weight  <span class=\"token comment\">// we can further reduce the distance -> negative cycle in here</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Theorem: If <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?G=(V, E)\"></img> contains no negative weight cycles then after Bellman-Ford executes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v] = \\delta(s,v)\"></img> for all <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v \\in V\"></img>.\nCorollary: if a value <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v]\"></img> fails to convert after <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m-1\"></img> passes there exists a negative cycles reachable from s. </p>\n<p>Let <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?G = (V, E)\"></img> be a weighted, directed graph and let <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> be a source vertex. Consider any shortest path <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p =  \\langle v_0, v_1, \\dots , v_k \\rangle\"></img> from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s  = v_0 \"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v = v_k\"></img>. Then a sequence of relaxation steps occour that include, in order, relaxing the edges <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_0, v_1)\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_1, v_2)\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\dots\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_{k-1}, v_k)\"></img>, Then <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_k] = \\delta(s, v_k)\"></img>. For the basis case this is trivially true as <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_0] = \\delta(s, s) = 0\"></img>. Inductively, we have that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_{i-1}] = \\delta(s, v_{i-1})\"></img>. After relaxing the edge <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_{i-1}, v_i)\"></img> we have that </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\begin{align}\nd[v_i] &amp;\\leq d[v_{i-1}] + w(u_{i-1}, u_i) \\\\ \n&amp;= \\delta(s, v_{i-1}) + w(u_{i-1}, u_i)  \\\\\n&amp;= \\delta(s, v_i)\n\\end{align}\"></div>\n<p>Where step 2 to 3 comes from the fact that we know that the path <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p\"></img> passing through <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_{i-1}\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_i\"></img> is the shortest path. Thus at the next relaxation step <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_i]\"></img> will store the shortest path distance. This is called convergence property. Furthermore, when we use the relaxation property. When we use this property, relaxing an edge in the optimal path subsequently we have the path relaxation property. This is what Bellman-Ford is doing. At each for loop it relaxes all the edges, so that we are sure we are relaxing also <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_0, v_1)\"></img> of the shortest path and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_1]= \\delta(v_0, v_1)\"></img>. In the second loop, thanks to the convergence property, and the fact we are going through all the edges, we are relaxing also <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?(v_1, v2)\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_2] = \\delta(v_0, v_2)\"></img>.</p>\n<p>Rephrased differently: at iteration <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img> of the for loop, the algorithm will find all the shortest paths of length <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img>. So if node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> is on a shortest path of length <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img>, after iteration <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[x] = \\delta(s, x)\"></img>. At each iteration Bellman-Ford expands the frontier of shortest paths and find the shortest paths of length 1, 2, ... <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m-1.\"></img> That means that after <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?m -1\"></img> iterations we have all the shortest paths. </p>\n<p>We run an additional relaxation round to check the existence of negative cycles. If we can further relax a path to a vertex, that means that a path could be extended further, but given the previous propositions, that means that we are visiting a node more then once and that a negative cycle exists. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 667px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4b7b54c9c572a81f6a5788a5959b9ff6/295bd/adb555fd93422255b00e98b976618ee6dc60e49c.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.764705882352935%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABgklEQVQoz21SXW+DMAzs//9lkybtYQ992Va1sEFpgHyQhAAJNycUVLpFMkmMfT5ffJhnpHXfELSBvTKsa14Dnparavq4LWaNO0So5PABzjoUxxLVew7BOvjR7xJCIJum9O/yckJzrtHJflf8kFhNHvaHYWAtZG2QfTZo8hbmXGIyw8becQ2blRiVQZVLlBmHOldwJYPRC/BhpToIBVm06JSDkhbsImAKloptkngPc+NoCoVhnFB9K4isodwO4zguDB81Ko8FmhODazXy1y90xOhZIysN8rcLbK3RflwpJ4efw75lTyykEOhv1HbdwXCD6dYkRo+ACZKY+VpAc4uRKwSpYIxJDO+PQgkhYBgGerSBgCWEIG1IpzAvzT4yjA/TNhxSCoqT6VwzRjLJvYbr8BitCUzB9f2/4xLjdadJa5ViI7u499YugIHY8ZZTUJeqqHsLcY8ycM5TAUHn6It3TQARVOsFLHYVcbaWo4bREUizieYs3pOtd+//WPRvRrqunf4CxjYKG4Hpwn8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"adb555fd93422255b00e98b976618ee6dc60e49c.png\"\n        title=\"adb555fd93422255b00e98b976618ee6dc60e49c.png\"\n        src=\"/static/4b7b54c9c572a81f6a5788a5959b9ff6/295bd/adb555fd93422255b00e98b976618ee6dc60e49c.png\"\n        srcset=\"/static/4b7b54c9c572a81f6a5788a5959b9ff6/04472/adb555fd93422255b00e98b976618ee6dc60e49c.png 170w,\n/static/4b7b54c9c572a81f6a5788a5959b9ff6/9f933/adb555fd93422255b00e98b976618ee6dc60e49c.png 340w,\n/static/4b7b54c9c572a81f6a5788a5959b9ff6/295bd/adb555fd93422255b00e98b976618ee6dc60e49c.png 667w\"\n        sizes=\"(max-width: 667px) 100vw, 667px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Longest Simple Path and Shortest Simple Path</h2>\n<p>Finding the longest simple path in a graph with non-negative edge weights is an NP-Hard problem, for which no known polynomial-time algorithm exists. </p>\n<p>Suppose one simply negates each of the edge weights and runs Bellman-Ford to compute shortest paths. Bellman-Ford will not necessarily compute the longest paths in the original graph, since there might be a negative-weight cycle reachable from the source, and the algorithm will abort.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2dd2bc56b300d01e5fc92de0d11c7cbf/e35ec/eb9d74d6e3e92603205c1df8c53857382463044d.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsSAAALEgHS3X78AAAAqElEQVQY01WPyQ7EIAxD+f8vrMSBntojXRiWQss8YWk09cFyHCcE8zxP7x2+71tapYRMUEqJMS7Lsq7rtm1lwOScW2t5gBoNp5Su65JPCR/HIZN1CBbBJg2c5xkHiH4GyNVaGcOk673XDH4IAR82rNeFJLAQhHQVbT0FaO37Tos8PgLT9D+QYAU9NM+S0OfJUSJ+f1H+NUxDh/U38Od5ds5Za6dpgt3AF2XnXMpLx3XVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eb9d74d6e3e92603205c1df8c53857382463044d.png\"\n        title=\"eb9d74d6e3e92603205c1df8c53857382463044d.png\"\n        src=\"/static/2dd2bc56b300d01e5fc92de0d11c7cbf/c5bb3/eb9d74d6e3e92603205c1df8c53857382463044d.png\"\n        srcset=\"/static/2dd2bc56b300d01e5fc92de0d11c7cbf/04472/eb9d74d6e3e92603205c1df8c53857382463044d.png 170w,\n/static/2dd2bc56b300d01e5fc92de0d11c7cbf/9f933/eb9d74d6e3e92603205c1df8c53857382463044d.png 340w,\n/static/2dd2bc56b300d01e5fc92de0d11c7cbf/c5bb3/eb9d74d6e3e92603205c1df8c53857382463044d.png 680w,\n/static/2dd2bc56b300d01e5fc92de0d11c7cbf/e35ec/eb9d74d6e3e92603205c1df8c53857382463044d.png 861w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Similarly, if we have a graph with negative cycles, and we wish to find the longest simple path (a path without a cycle) from the source s to a vertex v, we cannot use Bellman-Ford It will again abort if there is a negative weight cycle. The shortest simple path problem is also NP-hard: we don't know any algorithm that is better than exponential time that can solve it. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 551px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f3712b22a9b0f73cc57ac82f3563ad44/db783/5015d46864ef93db984e529570d8ba3931b9ade9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.705882352941174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAAAsklEQVQY042PzQrDIBCEff/3CznoJRAlCCEQjUlsfvrVpaUHCx1Q1tmZnVWFEJZliTHeBfu+xwIKYY7jQAOTUhKGgiek4tDG3/e91toYc55nznkYBmtt13VN0zBo27ZxHJ1zbdvCPwpeZknLBUwNBeu6igIbXbkRiJgneeq6Liru+w1s3nvWgWQLutM0MeVbwwha6q4B5zzPkiCDqrKKWRLYHyeBFIT8a/6Ek8zC/OKX5glJ0ZgKpoF8/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5015d46864ef93db984e529570d8ba3931b9ade9.png\"\n        title=\"5015d46864ef93db984e529570d8ba3931b9ade9.png\"\n        src=\"/static/f3712b22a9b0f73cc57ac82f3563ad44/db783/5015d46864ef93db984e529570d8ba3931b9ade9.png\"\n        srcset=\"/static/f3712b22a9b0f73cc57ac82f3563ad44/04472/5015d46864ef93db984e529570d8ba3931b9ade9.png 170w,\n/static/f3712b22a9b0f73cc57ac82f3563ad44/9f933/5015d46864ef93db984e529570d8ba3931b9ade9.png 340w,\n/static/f3712b22a9b0f73cc57ac82f3563ad44/db783/5015d46864ef93db984e529570d8ba3931b9ade9.png 551w\"\n        sizes=\"(max-width: 551px) 100vw, 551px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>The bold arrow show the shortest simple path. Bellman-Ford cannot detect it because of the presence of the negative cycle and it will abort. </em></p>\n<h2>Speeding Up Dijkstra</h2>\n<p>This section is about improving performance with respect to a naïve implementation. The original Dijkstra's and Bellman-Ford we implicitly find the shortest path from the source node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> to any other node. There is room for improvement if we know that we want to find the shortest path to a specific target node. We have a bunch of different classes problems, e.g:</p>\n<ul>\n<li>single source, single target problem</li>\n<li>all pairs shortest paths problem (find the shortest path between each set of vertices)</li>\n</ul>\n<p>Speedup techniques covered here do not change worst-case behavior, but reduce the number of visited vertices in practice. One simple improvement is, for example, to stop Dijkstra once we have the target node popped up the priority queue. </p>\n<h3>Bi-Directional Search</h3>\n<p>We grow two frontiers alternatively from the start and the target node. When the same node gets pulled of the priority queue, then the two frontiers have met. We can terminate the algorithm. The question is: can we use the node where the two frontiers met as the intermediate node that joins the two shortest path into a single shortest path? The answer is no. In fact the frontiers meet over a vertex that not necessarily belong to the overall shortest path. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">bidirectional_search</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 1) Forward search from s </span>\n  <span class=\"token comment\">// 2) Backward search from t (going up to the parents)</span>\n  <span class=\"token comment\">// - df[u] are the distances for forward search from s</span>\n  <span class=\"token comment\">// - db[u] are the distances for backward search from t </span>\n  <span class=\"token comment\">// 3) Terminate when some vertex w has been deleted from both forward and backward queue Qf and Qb</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 445px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6bd8f0df7f432d2e66ee63fcf90eb2b7/e66bf/78c39900d36953fe922c9779149a4e01971dfd58.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.88235294117646%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAB7UlEQVQ4y31Ta4/TMBDs//9f8BHxBQnBwXF3fSeO42dix/YwdlpaeghLq7Wz29md2e2moKCeUlaf6Zd2Le1e2m2N15TVv7crxuYezKUCGTPGOSGun4ApoLjpr6K30yo0K5cmNtckv2TopaLOyFJD+oBnI6B6AQwjclpaXsgF8WKJ70hLV3hCba40VV4DJ3FAERI/RgGZmO5neDPhJXiIuMAzyVITTTaCMfP1FeNRNmCslAs8kf1gMb9sYaJnhQxHOxFkF2cCRSSCnaPFsFjYPMMi4NvwgvThE+bvO9gr5eokq5kvT8DHz6S86hX4jVLi1+RwOJ1IW2FwI559h071MMsEVyKy81CVxQ2wtg8sFL9qtZ9GpBCa3mYdN576M8KoWIAUpUDsBIKxLVZlkstlOLhoWIVWaf1gpEQ4C2glIJaEoA3Ok8bIsYeaEjgcW2VZR6EJtuS7tfmzMgzUjspMebWFnjV2ktMVqr05Mw6DK8WcLQm8TYWW0YWHPbzfLckutkx65SiPsTZDGFIrIV7Xv3VT4z9daoCHObcVegdYV+fI4IHV92TVx8cl/v8p9xre/32id3BjHQxXwxgoamrZpeHdUE+tFBS9Ys586fwflG+A9Yf73R7WOgJo9F2HQQzNy2H1gu+h7+G4Mo8N/QYZNfiJz3v/lgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"78c39900d36953fe922c9779149a4e01971dfd58.png\"\n        title=\"78c39900d36953fe922c9779149a4e01971dfd58.png\"\n        src=\"/static/6bd8f0df7f432d2e66ee63fcf90eb2b7/e66bf/78c39900d36953fe922c9779149a4e01971dfd58.png\"\n        srcset=\"/static/6bd8f0df7f432d2e66ee63fcf90eb2b7/04472/78c39900d36953fe922c9779149a4e01971dfd58.png 170w,\n/static/6bd8f0df7f432d2e66ee63fcf90eb2b7/9f933/78c39900d36953fe922c9779149a4e01971dfd58.png 340w,\n/static/6bd8f0df7f432d2e66ee63fcf90eb2b7/e66bf/78c39900d36953fe922c9779149a4e01971dfd58.png 445w\"\n        sizes=\"(max-width: 445px) 100vw, 445px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>After search terminates, we find the node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> with minimum value of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_f[x] + d_b[x]\"></img>. <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> may not be the vertex <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?w\"></img> that caused termination as in the example below. We then find the shortest path from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> using <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Pi_f\"></img> and shortest path backward from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t \"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> using <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\Pi_b\"></img>. Note that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?x\"></img> will have been deleted from either <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?Q_b\"></img> or <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?Q_f\"></img> or both. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/730ce37e4b50e60eabc47859228424df/f1c64/74a0520b7caca37536e94b0510dc94f026ea7d70.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.94117647058824%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABHUlEQVQoz3VQy3LDMAj0//9jT53WTfyIhBACSeAiO81MD+Gg0cICu0zCUpG7VDuMmSWVRnKcQUQiol2d41BVTa3kYmYXYUprKDFLJE9VJAaC296kXuUM+TGvHNCrlMY//Ky99WdzSZlCZiwOrPWaKO0ghQc0C7eNE8H9YaqD+UDcIQNeq6dBUj3+wkW6thf0f83cartgL+Jz7YzRbKaHDdKwdKZyzrXWy3Pv/XgfU1zD43shyN4etxDmdXNXpxYfp7VVID03+34/qPjgKtfQKS47rDHed9O+ff74LFiCMJ+iTYAE2c/pCBFDiAApY+aT4AcjDMlXSa8uYv6aWfil1nc24mPYMXeBCf3lws/ml4GlwYcsqPUwe2fS/pd+AQXyDl5QLzg5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"74a0520b7caca37536e94b0510dc94f026ea7d70.png\"\n        title=\"74a0520b7caca37536e94b0510dc94f026ea7d70.png\"\n        src=\"/static/730ce37e4b50e60eabc47859228424df/c5bb3/74a0520b7caca37536e94b0510dc94f026ea7d70.png\"\n        srcset=\"/static/730ce37e4b50e60eabc47859228424df/04472/74a0520b7caca37536e94b0510dc94f026ea7d70.png 170w,\n/static/730ce37e4b50e60eabc47859228424df/9f933/74a0520b7caca37536e94b0510dc94f026ea7d70.png 340w,\n/static/730ce37e4b50e60eabc47859228424df/c5bb3/74a0520b7caca37536e94b0510dc94f026ea7d70.png 680w,\n/static/730ce37e4b50e60eabc47859228424df/b12f7/74a0520b7caca37536e94b0510dc94f026ea7d70.png 1020w,\n/static/730ce37e4b50e60eabc47859228424df/b5a09/74a0520b7caca37536e94b0510dc94f026ea7d70.png 1360w,\n/static/730ce37e4b50e60eabc47859228424df/f1c64/74a0520b7caca37536e94b0510dc94f026ea7d70.png 1390w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>The dashed circle, means that the vertex has been popped from a priority queue. Horizontal and vertical lines mean that has been popped from the forward and backward queues respectively. At step 3 the same vertex (w) is popped of the two queues. We can terminate the algorithm and find the vertex where distance from both ends is the minimum (summing up all the distance vectors). </em></p>\n<h2>Labeling correcting methods</h2>\n<p>Now look at more efficient approaches to solving shortest path (SP) problems. In SP problems, we are interested in reaching a destination node from a starting node in the shortest way possible. In the Label Correcting Algorithm, we progressively discover paths from s to other nodes <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i \\in V\"></img> and keep track of the associated lengths to get to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img>, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[i]\"></img>. In LCA, we also keep updating an open bin (in Dijktstra represented as a queue) which is the current list of nodes that could potentially be a part of the shortest path to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t\"></img>. </p>\n<p>As with Dijkstra, we assume that the weights are non-negative and there are no negative cycles. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d3f3f66a30110b54a66687b56c9191a4/73b94/2945672de3773c2ad11ee62a962c1054948cfa92.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAABw0lEQVQ4y31TiXKCMBD1//+qM51paz06tYgnCpYz3CqIiq/Z2KXSKzNLIMl7ebtv6eBzXC4X/Da+r59OJxyPx1bQGp/t3ILO57M6QDMFrQshkMQJ6rpWwN1uh7IoUFVXskK+Hw6H3wnTNFWAMAzh2A6iKIbruHKOFHC/3yPLsivhoVJEZVlK8uqLkB5MSGS8cT5JhfXlR8qcJhGTav5uKeSRZylCEdJOq4aUKgVfTkRBECjFt4IUoedHCESCMM6xNEzYboAwyuC4AtvtVbHwA8RxzDeoyfd9JEnSEDFpZ7mysDAsjMYGNH0JbbLCZG6hN9Th+UIdohoSmFJjxXmeN0aS4kbhZLbGbGFBl3MogTRPFxv0h2OsTUsVncyi9KjGRE4mcJAxLZffdEMqMjGervGqLZRS2/bw2B1An8ykqkrVi1ImUmqj3XZ7dVi6XeyLtinWuwvb8UFKXU9IhaZS/NwfwViZElg27cQKuV/ZrFbbdPtvGL5OMdLmktTAy2iG54GGu/uevCBALcGquWUNCUhkTMTRqmGcpLCsDbrdHh4fnqTTaziOh8273dSG/5z/RuMyf3BNKBVBPXbT5Legv4L3PwB8wun7UcD7cQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2945672de3773c2ad11ee62a962c1054948cfa92.png\"\n        title=\"2945672de3773c2ad11ee62a962c1054948cfa92.png\"\n        src=\"/static/d3f3f66a30110b54a66687b56c9191a4/c5bb3/2945672de3773c2ad11ee62a962c1054948cfa92.png\"\n        srcset=\"/static/d3f3f66a30110b54a66687b56c9191a4/04472/2945672de3773c2ad11ee62a962c1054948cfa92.png 170w,\n/static/d3f3f66a30110b54a66687b56c9191a4/9f933/2945672de3773c2ad11ee62a962c1054948cfa92.png 340w,\n/static/d3f3f66a30110b54a66687b56c9191a4/c5bb3/2945672de3773c2ad11ee62a962c1054948cfa92.png 680w,\n/static/d3f3f66a30110b54a66687b56c9191a4/73b94/2945672de3773c2ad11ee62a962c1054948cfa92.png 1004w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>STEP 0: place node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s \"></img> in OPEN, set <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_s = 0\"></img> and <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_j =\\infty\"></img> <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\forall j \\in V \\ \\{s\\}\"></img>.</li>\n<li>STEP 1: remove a node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img> from OPEN and execute step 2 for all children <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?j \"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img></li>\n<li>STEP 2: if <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_i + c_{i,j} < d_j \"></img> (relaxation) and also this total cost is less then the current cost to the target which is <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_i + c_{i,j}  <d_t\"></img> set <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_i = d_j + c_{i,j}\"></img> and set <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?i\"></img> to bet the parent of <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?j\"></img> in the path from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?t\"></img>. If <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?j \\neq t\"></img>, put <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?j\"></img> in OPEN if it is not already there.   </li>\n<li>STEP 3: if OPEN is empty, we are done, otherwise go to STEP 1</li>\n</ul>\n<p>Notice that the biggest difference with respect to Dijkstra is that we do not choose nodes in step 1 as the one with the minimum weight. Instead, we just take one node that has to be processed yet. Nevertheless, the procedure is correct. Why? </p>\n<h3>Proof</h3>\n<ul>\n<li>Let <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p\"></img> bet the shortest path <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\langle s, v_1, v_2, \\dots, v_{k-2} , t\\rangle\"></img> with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?k\"></img> vertices and length <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d*\"></img>. Note that by the principle of optimality each sub-path <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?p_m = \\langle s, v_1, v_2, \\dots, v_m\\rangle\"></img> is an optimal path from <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s \"></img> to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_m\"></img>. </li>\n<li>Assume by contradiction that the algorithm terminates with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_t > d^*\"></img>. The it is also true that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_t > d_m, m=\\{1 \\dots, k-2\\}\"></img> (as weight are only non-negative and non-negative cycles). This implies that <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_{k-2}\"></img> does not enter OPEN with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d[v_{k-2}] = d^*_{k-2}\"></img>otherwise the next time <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_{k-2}\"></img> is removed from OPEN, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_t\"></img> would be updated to <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d^*\"></img>. </li>\n<li>Similarly <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_{k-3}\"></img> will not enter OPEN with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_{k-3} = d^*_{k-3}\"></img>. <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?\\square\"></img></li>\n<li>Continuing this way, <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?v_1\"></img> will not enter OPEN with <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_{1} = d^*_1 = c_{s, v_1}\"></img>. But this happens at the first iteration of the algorithm, which leads to a contradiction. Hence <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?d_t = d^*\"></img> upon completion of the algorithm.</li>\n</ul>\n<p>In other words, the algorithm expands the frontier from the starting node <img class=\"inline-equation-image\" src=\"https://latex.codecogs.com/svg.latex?s\"></img>. Independently from how the nodes get processed, thank to the principle of optimality, we know that after the first iteration we have all the optimal 1 edge path, distances from the source. After iteration 2 we have all the optimal 2 edges path from the source and so forth.</p>\n<p>Note that Dijkstra’s is obtained as a particular case of LCA when we select the smallest distance node as the one to remove from OPEN (implemented as priority queue) and the second check is never performed </p>\n<div class=\"block-equation-container\"><img src=\"https://latex.codecogs.com/svg.latex?\\text{Dijkstra } \\Rightarrow \\begin{cases}\ni &amp;= \\arg \\min d_i \\\\\nd_T &amp;= \\infty  \n\\end{cases}\"></div>","frontmatter":{"title":"Shortest Path","description":"Array","image":{"childImageSharp":{"resize":{"src":"/static/241e6c0fe2b66666656502910bd0368d/72b5a/988b0a825d536e52d0b4df278b3d3eab04f16bf6.png","height":630,"width":1200}}}}}},"pageContext":{"slug":"/shortest-path/","previousPost":{"title":"Sorting","slug":"/sorting/"},"nextPost":{"title":"Patterns","slug":"/patterns/"}}},"staticQueryHashes":["3868140423","4085307986"]}